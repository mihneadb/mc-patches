# HG changeset patch
# User Mihnea Dobrescu-Balaur <mihneadb@gmail.com>
# Date 1374800539 25200
#      Thu Jul 25 18:02:19 2013 -0700
# Node ID 8b60b46735de8dd9ee411afc3d0affd60dfc0827
# Parent a587326a1f8f272cebd0dd20ee7b72e5e79dead1
Bug 887054 - Adapt mobile xpcshell harnesses to the changes from parxpc

diff --git a/testing/xpcshell/remotexpcshelltests.py b/testing/xpcshell/remotexpcshelltests.py
--- a/testing/xpcshell/remotexpcshelltests.py
+++ b/testing/xpcshell/remotexpcshelltests.py
@@ -1,281 +1,69 @@
 #!/usr/bin/env python
 #
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
+import posixpath
 import sys, os
 import subprocess
 import runxpcshelltests as xpcshell
 import tempfile
 from automationutils import replaceBackSlashes
 import devicemanagerADB, devicemanagerSUT, devicemanager
 from zipfile import ZipFile
 import shutil
 
 here = os.path.dirname(os.path.abspath(__file__))
 
-# A specialization of XPCShellTests that runs tests on an Android device
-# via devicemanager.
-class XPCShellRemote(xpcshell.XPCShellTests, object):
+def remoteJoin(path1, path2):
+    return posixpath.join(path1, path2)
 
-    def __init__(self, devmgr, options, args):
-        xpcshell.XPCShellTests.__init__(self)
-        self.localLib = options.localLib
-        self.localBin = options.localBin
-        self.options = options
-        self.device = devmgr
-        self.pathMapping = []
-        self.remoteTestRoot = self.device.getTestRoot("xpcshell")
-        # remoteBinDir contains xpcshell and its wrapper script, both of which must
-        # be executable. Since +x permissions cannot usually be set on /mnt/sdcard,
-        # and the test root may be on /mnt/sdcard, remoteBinDir is set to be on
-        # /data/local, always.
-        self.remoteBinDir = "/data/local/xpcb"
-        # Terse directory names are used here ("c" for the components directory)
-        # to minimize the length of the command line used to execute
-        # xpcshell on the remote device. adb has a limit to the number
-        # of characters used in a shell command, and the xpcshell command
-        # line can be quite complex.
-        self.remoteTmpDir = self.remoteJoin(self.remoteTestRoot, "tmp")
-        self.remoteScriptsDir = self.remoteTestRoot
-        self.remoteComponentsDir = self.remoteJoin(self.remoteTestRoot, "c")
-        self.remoteModulesDir = self.remoteJoin(self.remoteTestRoot, "m")
-        self.profileDir = self.remoteJoin(self.remoteTestRoot, "p")
-        self.remoteDebugger = options.debugger
-        self.remoteDebuggerArgs = options.debuggerArgs
-        self.testingModulesDir = options.testingModulesDir
+class RemoteXPCShellTestThread(xpcshell.XPCShellTestThread):
+    def __init__(self, *args, **kwargs):
+        xpcshell.XPCShellTestThread.__init__(self, *args, **kwargs)
 
-        if self.options.objdir:
-            self.xpcDir = os.path.join(self.options.objdir, "_tests/xpcshell")
-        elif os.path.isdir(os.path.join(here, 'tests')):
-            self.xpcDir = os.path.join(here, 'tests')
+        # embed the mobile params from the harness into the TestThread
+        mobileArgs = kwargs.get('mobileArgs')
+        for key in mobileArgs:
+            setattr(self, key, mobileArgs[key])
+
+    def buildCmdTestFile(self, name):
+        remoteDir = self.remoteForLocal(os.path.dirname(name))
+        if remoteDir == self.remoteHere:
+            remoteName = os.path.basename(name)
         else:
-            print >> sys.stderr, "Couldn't find local xpcshell test directory"
-            sys.exit(1)
-
-        if options.localAPK:
-            self.localAPKContents = ZipFile(options.localAPK)
-        if options.setup:
-            self.setupUtilities()
-            self.setupModules()
-            self.setupTestDir()
-        if options.localAPK:
-            self.remoteAPK = self.remoteJoin(self.remoteBinDir, os.path.basename(options.localAPK))
-            self.setAppRoot()
-
-    def setAppRoot(self):
-        # Determine the application root directory associated with the package
-        # name used by the Fennec APK.
-        self.appRoot = None
-        packageName = None
-        if self.options.localAPK:
-            try:
-                packageName = self.localAPKContents.read("package-name.txt")
-                if packageName:
-                    self.appRoot = self.device.getAppRoot(packageName.strip())
-            except Exception as detail:
-                print "unable to determine app root: " + str(detail)
-                pass
-        return None
-
-    def remoteJoin(self, path1, path2):
-        joined = os.path.join(path1, path2)
-        joined = joined.replace('\\', '/')
-        return joined
+            remoteName = remoteJoin(remoteDir, os.path.basename(name))
+        return ['-e', 'const _TEST_FILE = ["%s"];' %
+                 replaceBackSlashes(remoteName)]
 
     def remoteForLocal(self, local):
         for mapping in self.pathMapping:
             if (os.path.abspath(mapping.local) == os.path.abspath(local)):
                 return mapping.remote
         return local
 
-    def setupUtilities(self):
-        if (not self.device.dirExists(self.remoteBinDir)):
-            # device.mkDir may fail here where shellCheckOutput may succeed -- see bug 817235
-            try:
-                self.device.shellCheckOutput(["mkdir", self.remoteBinDir]);
-            except devicemanager.DMError:
-                # Might get a permission error; try again as root, if available
-                self.device.shellCheckOutput(["mkdir", self.remoteBinDir], root=True);
-                self.device.shellCheckOutput(["chmod", "777", self.remoteBinDir], root=True);
-
-        remotePrefDir = self.remoteJoin(self.remoteBinDir, "defaults/pref")
-        if (self.device.dirExists(self.remoteTmpDir)):
-            self.device.removeDir(self.remoteTmpDir)
-        self.device.mkDir(self.remoteTmpDir)
-        if (not self.device.dirExists(remotePrefDir)):
-            self.device.mkDirs(self.remoteJoin(remotePrefDir, "extra"))
-        if (not self.device.dirExists(self.remoteScriptsDir)):
-            self.device.mkDir(self.remoteScriptsDir)
-        if (not self.device.dirExists(self.remoteComponentsDir)):
-            self.device.mkDir(self.remoteComponentsDir)
-
-        local = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'head.js')
-        remoteFile = self.remoteJoin(self.remoteScriptsDir, "head.js")
-        self.device.pushFile(local, remoteFile)
-
-        local = os.path.join(self.localBin, "xpcshell")
-        remoteFile = self.remoteJoin(self.remoteBinDir, "xpcshell")
-        self.device.pushFile(local, remoteFile)
-
-        local = os.path.join(self.localBin, "components/httpd.js")
-        remoteFile = self.remoteJoin(self.remoteComponentsDir, "httpd.js")
-        self.device.pushFile(local, remoteFile)
-
-        local = os.path.join(self.localBin, "components/httpd.manifest")
-        remoteFile = self.remoteJoin(self.remoteComponentsDir, "httpd.manifest")
-        self.device.pushFile(local, remoteFile)
-
-        local = os.path.join(self.localBin, "components/test_necko.xpt")
-        remoteFile = self.remoteJoin(self.remoteComponentsDir, "test_necko.xpt")
-        self.device.pushFile(local, remoteFile)
-
-        if self.options.localAPK:
-            remoteFile = self.remoteJoin(self.remoteBinDir, os.path.basename(self.options.localAPK))
-            self.device.pushFile(self.options.localAPK, remoteFile)
-
-        self.pushLibs()
-
-    def pushLibs(self):
-        if self.options.localAPK:
-            try:
-                dir = tempfile.mkdtemp()
-                szip = os.path.join(self.localBin, '..', 'host', 'bin', 'szip')
-                if not os.path.exists(szip):
-                    # Tinderbox builds must run szip from the test package
-                    szip = os.path.join(self.localBin, 'host', 'szip')
-                if not os.path.exists(szip):
-                    # If the test package doesn't contain szip, it means files
-                    # are not szipped in the test package.
-                    szip = None
-                for info in self.localAPKContents.infolist():
-                    if info.filename.endswith(".so"):
-                        print >> sys.stderr, "Pushing %s.." % info.filename
-                        remoteFile = self.remoteJoin(self.remoteBinDir, os.path.basename(info.filename))
-                        self.localAPKContents.extract(info, dir)
-                        file = os.path.join(dir, info.filename)
-                        if szip:
-                            out = subprocess.check_output([szip, '-d', file], stderr=subprocess.STDOUT)
-                        self.device.pushFile(os.path.join(dir, info.filename), remoteFile)
-            finally:
-                shutil.rmtree(dir)
-            return
-
-        for file in os.listdir(self.localLib):
-            if (file.endswith(".so")):
-                print >> sys.stderr, "Pushing %s.." % file
-                if 'libxul' in file:
-                    print >> sys.stderr, "This is a big file, it could take a while."
-                remoteFile = self.remoteJoin(self.remoteBinDir, file)
-                self.device.pushFile(os.path.join(self.localLib, file), remoteFile)
-
-        # Additional libraries may be found in a sub-directory such as "lib/armeabi-v7a"
-        localArmLib = os.path.join(self.localLib, "lib")
-        if os.path.exists(localArmLib):
-            for root, dirs, files in os.walk(localArmLib):
-                for file in files:
-                    if (file.endswith(".so")):
-                        print >> sys.stderr, "Pushing %s.." % file
-                        remoteFile = self.remoteJoin(self.remoteBinDir, file)
-                        self.device.pushFile(os.path.join(root, file), remoteFile)
-
-    def setupModules(self):
-        if self.testingModulesDir:
-            self.device.pushDir(self.testingModulesDir, self.remoteModulesDir)
-
-    def setupTestDir(self):
-        print 'pushing %s' % self.xpcDir
-        try:
-            self.device.pushDir(self.xpcDir, self.remoteScriptsDir, retryLimit=10)
-        except TypeError:
-            # Foopies have an older mozdevice ver without retryLimit
-            self.device.pushDir(self.xpcDir, self.remoteScriptsDir)
-
-    def buildTestList(self):
-        xpcshell.XPCShellTests.buildTestList(self)
-        uniqueTestPaths = set([])
-        for test in self.alltests:
-            uniqueTestPaths.add(test['here'])
-        for testdir in uniqueTestPaths:
-            abbrevTestDir = os.path.relpath(testdir, self.xpcDir)
-            remoteScriptDir = self.remoteJoin(self.remoteScriptsDir, abbrevTestDir)
-            self.pathMapping.append(PathMapping(testdir, remoteScriptDir))
-
-    def buildXpcsCmd(self, testdir):
-        # change base class' paths to remote paths and use base class to build command
-        self.xpcshell = self.remoteJoin(self.remoteBinDir, "xpcw")
-        self.headJSPath = self.remoteJoin(self.remoteScriptsDir, 'head.js')
-        self.httpdJSPath = self.remoteJoin(self.remoteComponentsDir, 'httpd.js')
-        self.httpdManifest = self.remoteJoin(self.remoteComponentsDir, 'httpd.manifest')
-        self.testingModulesDir = self.remoteModulesDir
-        self.testharnessdir = self.remoteScriptsDir
-        xpcshell.XPCShellTests.buildXpcsCmd(self, testdir)
-        # remove "-g <dir> -a <dir>" and add "--greomni <apk>"
-        del(self.xpcsCmd[1:5])
-        if self.options.localAPK:
-            self.xpcsCmd.insert(3, '--greomni')
-            self.xpcsCmd.insert(4, self.remoteAPK)
-
-        if self.remoteDebugger:
-            # for example, "/data/local/gdbserver" "localhost:12345"
-            self.xpcsCmd = [
-              self.remoteDebugger,
-              self.remoteDebuggerArgs,
-              self.xpcsCmd]
-
-    def getHeadAndTailFiles(self, test):
-        """Override parent method to find files on remote device."""
-        def sanitize_list(s, kind):
-            for f in s.strip().split(' '):
-                f = f.strip()
-                if len(f) < 1:
-                    continue
-
-                path = self.remoteJoin(self.remoteHere, f)
-                if not self.device.fileExists(path):
-                    raise Exception('%s file does not exist: %s' % ( kind,
-                        path))
-
-                yield path
-
-        self.remoteHere = self.remoteForLocal(test['here'])
-
-        return (list(sanitize_list(test['head'], 'head')),
-                list(sanitize_list(test['tail'], 'tail')))
-
-    def buildCmdTestFile(self, name):
-        remoteDir = self.remoteForLocal(os.path.dirname(name))
-        if remoteDir == self.remoteHere:
-            remoteName = os.path.basename(name)
-        else:
-            remoteName = self.remoteJoin(remoteDir, os.path.basename(name))
-        return ['-e', 'const _TEST_FILE = ["%s"];' %
-                 replaceBackSlashes(remoteName)]
 
     def setupTempDir(self):
         # make sure the temp dir exists
         if not self.device.dirExists(self.remoteTmpDir):
             self.device.mkDir(self.remoteTmpDir)
-
-        self.env["XPCSHELL_TEST_TEMP_DIR"] = self.remoteTmpDir
-        if self.interactive:
-            self.log.info("TEST-INFO | temp dir is %s" % self.remoteTmpDir)
+        # env var is set in buildEnvironment
         return self.remoteTmpDir
 
     def setupPluginsDir(self):
         if not os.path.isdir(self.pluginsPath):
             return None
 
         # making sure tmp dir is set up
         self.setupTempDir()
 
-        pluginsDir = self.remoteJoin(self.remoteTmpDir, "plugins")
+        pluginsDir = remoteJoin(self.remoteTmpDir, "plugins")
         self.device.pushDir(self.pluginsPath, pluginsDir)
         if self.interactive:
             self.log.info("TEST-INFO | plugins dir is %s" % pluginsDir)
         return pluginsDir
 
     def setupProfileDir(self):
         self.device.removeDir(self.profileDir)
         self.device.mkDir(self.profileDir)
@@ -283,58 +71,57 @@ class XPCShellRemote(xpcshell.XPCShellTe
             self.log.info("TEST-INFO | profile dir is %s" % self.profileDir)
         return self.profileDir
 
     def logCommand(self, name, completeCmd, testdir):
         self.log.info("TEST-INFO | %s | full command: %r" % (name, completeCmd))
         self.log.info("TEST-INFO | %s | current directory: %r" % (name, self.remoteHere))
         self.log.info("TEST-INFO | %s | environment: %s" % (name, self.env))
 
-    def setupLeakLogging(self):
-        self.env["XPCOM_MEM_LEAK_LOG"] = self.remoteJoin(self.profileDir, "leaks.log")
-        return self.env["XPCOM_MEM_LEAK_LOG"]
+    def getHeadAndTailFiles(self, test):
+        """Override parent method to find files on remote device."""
+        def sanitize_list(s, kind):
+            for f in s.strip().split(' '):
+                f = f.strip()
+                if len(f) < 1:
+                    continue
 
-    def setLD_LIBRARY_PATH(self, env):
-        env["LD_LIBRARY_PATH"]=self.remoteBinDir
+                path = remoteJoin(self.remoteHere, f)
+                if not self.device.fileExists(path):
+                    raise Exception('%s file does not exist: %s' % ( kind,
+                        path))
 
-    def pushWrapper(self):
-        # Rather than executing xpcshell directly, this wrapper script is
-        # used. By setting environment variables and the cwd in the script,
-        # the length of the per-test command line is shortened. This is
-        # often important when using ADB, as there is a limit to the length
-        # of the ADB command line.
-        localWrapper = tempfile.mktemp()
-        f = open(localWrapper, "w")
-        f.write("#!/system/bin/sh\n")
-        for envkey, envval in self.env.iteritems():
-            f.write("export %s=%s\n" % (envkey, envval))
-        f.write("cd $1\n")
-        f.write("echo xpcw: cd $1\n")
-        f.write("shift\n")
-        f.write("echo xpcw: xpcshell \"$@\"\n")
-        f.write("%s/xpcshell \"$@\"\n" % self.remoteBinDir)
-        f.close()
-        remoteWrapper = self.remoteJoin(self.remoteBinDir, "xpcw")
-        self.device.pushFile(localWrapper, remoteWrapper)
-        os.remove(localWrapper)
-        self.device.chmodDir(self.remoteBinDir)
+                yield path
 
-    def buildEnvironment(self):
-        self.env = {}
-        self.buildCoreEnvironment()
-        self.setLD_LIBRARY_PATH(self.env)
-        self.env["MOZ_LINKER_CACHE"]=self.remoteBinDir
-        if self.options.localAPK and self.appRoot:
-            self.env["GRE_HOME"]=self.appRoot
-        self.env["XPCSHELL_TEST_PROFILE_DIR"]=self.profileDir
-        self.env["TMPDIR"]=self.remoteTmpDir
-        self.env["HOME"]=self.profileDir
-        self.setupTempDir()
-        if self.options.setup:
-            self.pushWrapper()
+        self.remoteHere = self.remoteForLocal(test['here'])
+
+        return (list(sanitize_list(test['head'], 'head')),
+                list(sanitize_list(test['tail'], 'tail')))
+
+    def buildXpcsCmd(self, testdir):
+        # change base class' paths to remote paths and use base class to build command
+        self.xpcshell = remoteJoin(self.remoteBinDir, "xpcw")
+        self.headJSPath = remoteJoin(self.remoteScriptsDir, 'head.js')
+        self.httpdJSPath = remoteJoin(self.remoteComponentsDir, 'httpd.js')
+        self.httpdManifest = remoteJoin(self.remoteComponentsDir, 'httpd.manifest')
+        self.testingModulesDir = self.remoteModulesDir
+        self.testharnessdir = self.remoteScriptsDir
+        xpcshell.XPCShellTestThread.buildXpcsCmd(self, testdir)
+        # remove "-g <dir> -a <dir>" and add "--greomni <apk>"
+        del(self.xpcsCmd[1:5])
+        if self.options.localAPK:
+            self.xpcsCmd.insert(3, '--greomni')
+            self.xpcsCmd.insert(4, self.remoteAPK)
+
+        if self.remoteDebugger:
+            # for example, "/data/local/gdbserver" "localhost:12345"
+            self.xpcsCmd = [
+              self.remoteDebugger,
+              self.remoteDebuggerArgs,
+              self.xpcsCmd]
 
     def launchProcess(self, cmd, stdout, stderr, env, cwd):
         cmd.insert(1, self.remoteHere)
         outputFile = "xpcshelloutput"
         f = open(outputFile, "w+")
         self.shellReturnCode = self.device.shell(cmd, f)
         f.close()
         # The device manager may have timed out waiting for xpcshell.
@@ -367,32 +154,255 @@ class XPCShellRemote(xpcshell.XPCShellTe
         else:
             return -1
 
     def removeDir(self, dirname):
         self.device.removeDir(dirname)
 
     #TODO: consider creating a separate log dir.  We don't have the test file structure,
     #      so we use filename.log.  Would rather see ./logs/filename.log
-    def createLogFile(self, test, stdout, leakLogs):
+    def createLogFile(self, test, stdout):
         try:
             f = None
             filename = test.replace('\\', '/').split('/')[-1] + ".log"
             f = open(filename, "w")
             f.write(stdout)
 
-            for leakLog in leakLogs:
-                if os.path.exists(leakLog):
-                    leaks = open(leakLog, "r")
-                    f.write(leaks.read())
-                    leaks.close()
         finally:
-            if f <> None:
+            if f is not None:
                 f.close()
 
+
+# A specialization of XPCShellTests that runs tests on an Android device
+# via devicemanager.
+class XPCShellRemote(xpcshell.XPCShellTests, object):
+
+    def __init__(self, devmgr, options, args):
+        xpcshell.XPCShellTests.__init__(self)
+        self.localLib = options.localLib
+        self.localBin = options.localBin
+        self.options = options
+        self.device = devmgr
+        self.pathMapping = []
+        self.remoteTestRoot = self.device.getTestRoot("xpcshell")
+        # remoteBinDir contains xpcshell and its wrapper script, both of which must
+        # be executable. Since +x permissions cannot usually be set on /mnt/sdcard,
+        # and the test root may be on /mnt/sdcard, remoteBinDir is set to be on
+        # /data/local, always.
+        self.remoteBinDir = "/data/local/xpcb"
+        # Terse directory names are used here ("c" for the components directory)
+        # to minimize the length of the command line used to execute
+        # xpcshell on the remote device. adb has a limit to the number
+        # of characters used in a shell command, and the xpcshell command
+        # line can be quite complex.
+        self.remoteTmpDir = remoteJoin(self.remoteTestRoot, "tmp")
+        self.remoteScriptsDir = self.remoteTestRoot
+        self.remoteComponentsDir = remoteJoin(self.remoteTestRoot, "c")
+        self.remoteModulesDir = remoteJoin(self.remoteTestRoot, "m")
+        self.profileDir = remoteJoin(self.remoteTestRoot, "p")
+        self.remoteDebugger = options.debugger
+        self.remoteDebuggerArgs = options.debuggerArgs
+        self.testingModulesDir = options.testingModulesDir
+
+        if self.options.objdir:
+            self.xpcDir = os.path.join(self.options.objdir, "_tests/xpcshell")
+        elif os.path.isdir(os.path.join(here, 'tests')):
+            self.xpcDir = os.path.join(here, 'tests')
+        else:
+            print >> sys.stderr, "Couldn't find local xpcshell test directory"
+            sys.exit(1)
+
+        if options.localAPK:
+            self.localAPKContents = ZipFile(options.localAPK)
+        if options.setup:
+            self.setupUtilities()
+            self.setupModules()
+            self.setupTestDir()
+        self.remoteAPK = None
+        if options.localAPK:
+            self.remoteAPK = remoteJoin(self.remoteBinDir, os.path.basename(options.localAPK))
+            self.setAppRoot()
+
+        # data that needs to be passed to the RemoteXPCShellTestThread
+        self.mobileArgs = {
+            'device': self.device,
+            'remoteBinDir': self.remoteBinDir,
+            'remoteScriptsDir': self.remoteScriptsDir,
+            'remoteComponentsDir': self.remoteComponentsDir,
+            'remoteModulesDir': self.remoteModulesDir,
+            'options': self.options,
+            'remoteDebugger': self.remoteDebugger,
+            'pathMapping': self.pathMapping,
+            'profileDir': self.profileDir,
+            'remoteTmpDir': self.remoteTmpDir,
+        }
+        if self.remoteAPK:
+            self.mobileArgs['remoteAPK'] = self.remoteAPK
+
+    def setLD_LIBRARY_PATH(self, env):
+        env["LD_LIBRARY_PATH"]=self.remoteBinDir
+
+    def pushWrapper(self):
+        # Rather than executing xpcshell directly, this wrapper script is
+        # used. By setting environment variables and the cwd in the script,
+        # the length of the per-test command line is shortened. This is
+        # often important when using ADB, as there is a limit to the length
+        # of the ADB command line.
+        localWrapper = tempfile.mktemp()
+        f = open(localWrapper, "w")
+        f.write("#!/system/bin/sh\n")
+        for envkey, envval in self.env.iteritems():
+            f.write("export %s=%s\n" % (envkey, envval))
+        f.write("cd $1\n")
+        f.write("echo xpcw: cd $1\n")
+        f.write("shift\n")
+        f.write("echo xpcw: xpcshell \"$@\"\n")
+        f.write("%s/xpcshell \"$@\"\n" % self.remoteBinDir)
+        f.close()
+        remoteWrapper = remoteJoin(self.remoteBinDir, "xpcw")
+        self.device.pushFile(localWrapper, remoteWrapper)
+        os.remove(localWrapper)
+        self.device.chmodDir(self.remoteBinDir)
+
+    def buildEnvironment(self):
+        self.env = {}
+        self.buildCoreEnvironment()
+        self.setLD_LIBRARY_PATH(self.env)
+        self.env["MOZ_LINKER_CACHE"] = self.remoteBinDir
+        if self.options.localAPK and self.appRoot:
+            self.env["GRE_HOME"] = self.appRoot
+        self.env["XPCSHELL_TEST_PROFILE_DIR"] = self.profileDir
+        self.env["TMPDIR"] = self.remoteTmpDir
+        self.env["HOME"] = self.profileDir
+        self.env["XPCSHELL_TEST_TEMP_DIR"] = self.remoteTmpDir
+        if self.options.setup:
+            self.pushWrapper()
+
+    def setAppRoot(self):
+        # Determine the application root directory associated with the package
+        # name used by the Fennec APK.
+        self.appRoot = None
+        packageName = None
+        if self.options.localAPK:
+            try:
+                packageName = self.localAPKContents.read("package-name.txt")
+                if packageName:
+                    self.appRoot = self.device.getAppRoot(packageName.strip())
+            except Exception as detail:
+                print "unable to determine app root: " + str(detail)
+                pass
+        return None
+
+    def setupUtilities(self):
+        if (not self.device.dirExists(self.remoteBinDir)):
+            # device.mkDir may fail here where shellCheckOutput may succeed -- see bug 817235
+            self.device.shellCheckOutput(["mkdir", self.remoteBinDir]);
+
+        remotePrefDir = remoteJoin(self.remoteBinDir, "defaults/pref")
+        if (self.device.dirExists(self.remoteTmpDir)):
+            self.device.removeDir(self.remoteTmpDir)
+        self.device.mkDir(self.remoteTmpDir)
+        if (not self.device.dirExists(remotePrefDir)):
+            self.device.mkDirs(remoteJoin(remotePrefDir, "extra"))
+        if (not self.device.dirExists(self.remoteScriptsDir)):
+            self.device.mkDir(self.remoteScriptsDir)
+        if (not self.device.dirExists(self.remoteComponentsDir)):
+            self.device.mkDir(self.remoteComponentsDir)
+
+        local = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'head.js')
+        remoteFile = remoteJoin(self.remoteScriptsDir, "head.js")
+        self.device.pushFile(local, remoteFile)
+
+        local = os.path.join(self.localBin, "xpcshell")
+        remoteFile = remoteJoin(self.remoteBinDir, "xpcshell")
+        self.device.pushFile(local, remoteFile)
+
+        local = os.path.join(self.localBin, "components/httpd.js")
+        remoteFile = remoteJoin(self.remoteComponentsDir, "httpd.js")
+        self.device.pushFile(local, remoteFile)
+
+        local = os.path.join(self.localBin, "components/httpd.manifest")
+        remoteFile = remoteJoin(self.remoteComponentsDir, "httpd.manifest")
+        self.device.pushFile(local, remoteFile)
+
+        local = os.path.join(self.localBin, "components/test_necko.xpt")
+        remoteFile = remoteJoin(self.remoteComponentsDir, "test_necko.xpt")
+        self.device.pushFile(local, remoteFile)
+
+        if self.options.localAPK:
+            remoteFile = remoteJoin(self.remoteBinDir, os.path.basename(self.options.localAPK))
+            self.device.pushFile(self.options.localAPK, remoteFile)
+
+        self.pushLibs()
+
+    def pushLibs(self):
+        if self.options.localAPK:
+            try:
+                dir = tempfile.mkdtemp()
+                szip = os.path.join(self.localBin, '..', 'host', 'bin', 'szip')
+                if not os.path.exists(szip):
+                    # Tinderbox builds must run szip from the test package
+                    szip = os.path.join(self.localBin, 'host', 'szip')
+                if not os.path.exists(szip):
+                    # If the test package doesn't contain szip, it means files
+                    # are not szipped in the test package.
+                    szip = None
+                for info in self.localAPKContents.infolist():
+                    if info.filename.endswith(".so"):
+                        print >> sys.stderr, "Pushing %s.." % info.filename
+                        remoteFile = remoteJoin(self.remoteBinDir, os.path.basename(info.filename))
+                        self.localAPKContents.extract(info, dir)
+                        file = os.path.join(dir, info.filename)
+                        if szip:
+                            out = subprocess.check_output([szip, '-d', file], stderr=subprocess.STDOUT)
+                        self.device.pushFile(os.path.join(dir, info.filename), remoteFile)
+            finally:
+                shutil.rmtree(dir)
+            return
+
+        for file in os.listdir(self.localLib):
+            if (file.endswith(".so")):
+                print >> sys.stderr, "Pushing %s.." % file
+                if 'libxul' in file:
+                    print >> sys.stderr, "This is a big file, it could take a while."
+                remoteFile = remoteJoin(self.remoteBinDir, file)
+                self.device.pushFile(os.path.join(self.localLib, file), remoteFile)
+
+        # Additional libraries may be found in a sub-directory such as "lib/armeabi-v7a"
+        localArmLib = os.path.join(self.localLib, "lib")
+        if os.path.exists(localArmLib):
+            for root, dirs, files in os.walk(localArmLib):
+                for file in files:
+                    if (file.endswith(".so")):
+                        print >> sys.stderr, "Pushing %s.." % file
+                        remoteFile = remoteJoin(self.remoteBinDir, file)
+                        self.device.pushFile(os.path.join(root, file), remoteFile)
+
+    def setupModules(self):
+        if self.testingModulesDir:
+            self.device.pushDir(self.testingModulesDir, self.remoteModulesDir)
+
+    def setupTestDir(self):
+        print 'pushing %s' % self.xpcDir
+        try:
+            self.device.pushDir(self.xpcDir, self.remoteScriptsDir, retryLimit=10)
+        except TypeError:
+            # Foopies have an older mozdevice ver without retryLimit
+            self.device.pushDir(self.xpcDir, self.remoteScriptsDir)
+
+    def buildTestList(self):
+        xpcshell.XPCShellTests.buildTestList(self)
+        uniqueTestPaths = set([])
+        for test in self.alltests:
+            uniqueTestPaths.add(test['here'])
+        for testdir in uniqueTestPaths:
+            abbrevTestDir = os.path.relpath(testdir, self.xpcDir)
+            remoteScriptDir = remoteJoin(self.remoteScriptsDir, abbrevTestDir)
+            self.pathMapping.append(PathMapping(testdir, remoteScriptDir))
+
 class RemoteXPCShellOptions(xpcshell.XPCShellOptions):
 
     def __init__(self):
         xpcshell.XPCShellOptions.__init__(self)
         defaults = {}
 
         self.add_option("--deviceIP", action="store",
                         type = "string", dest = "deviceIP",
@@ -521,15 +531,17 @@ def main():
         sys.exit(1)
 
     xpcsh = XPCShellRemote(dm, options, args)
 
     # we don't run concurrent tests on mobile
     options.sequential = True
 
     if not xpcsh.runTests(xpcshell='xpcshell',
+                          testClass=RemoteXPCShellTestThread,
                           testdirs=args[0:],
+                          mobileArgs=xpcsh.mobileArgs,
                           **options.__dict__):
         sys.exit(1)
 
 
 if __name__ == '__main__':
     main()
diff --git a/testing/xpcshell/runtestsb2g.py b/testing/xpcshell/runtestsb2g.py
--- a/testing/xpcshell/runtestsb2g.py
+++ b/testing/xpcshell/runtestsb2g.py
@@ -4,26 +4,48 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 import sys
 import os
 sys.path.insert(0, os.path.abspath(os.path.realpath(os.path.dirname(sys.argv[0]))))
 
 import traceback
-from remotexpcshelltests import XPCShellRemote, RemoteXPCShellOptions
+from remotexpcshelltests import RemoteXPCShellTestThread, XPCShellRemote, RemoteXPCShellOptions
 from mozdevice import devicemanagerADB, DMError
 
 DEVICE_TEST_ROOT = '/data/local/tests'
 
 
 from marionette import Marionette
 
+class B2GXPCShellTestThread(RemoteXPCShellTestThread):
+    # Overridden
+    def setLD_LIBRARY_PATH(self, env):
+        if self.options.use_device_libs:
+            env['LD_LIBRARY_PATH'] = '/system/b2g'
+            env['LD_PRELOAD'] = '/system/b2g/libmozglue.so'
+        else:
+            XPCShellRemote.setLD_LIBRARY_PATH(self, env)
+
+    # Overridden
+    def launchProcess(self, cmd, stdout, stderr, env, cwd):
+        try:
+            # This returns 1 even when tests pass - hardcode returncode to 0 (bug 773703)
+            outputFile = RemoteXPCShellTestThread.launchProcess(self, cmd, stdout, stderr, env, cwd)
+            self.shellReturnCode = 0
+        except DMError:
+            self.shellReturnCode = -1
+            outputFile = "xpcshelloutput"
+            f = open(outputFile, "a")
+            f.write("\n%s" % traceback.format_exc())
+            f.close()
+        return outputFile
+
 class B2GXPCShellRemote(XPCShellRemote):
-
     # Overridden
     def setupUtilities(self):
         if self.options.clean:
             # Ensure a fresh directory structure for our tests
             self.clean()
             self.device.mkDir(self.options.remoteTestRoot)
 
         XPCShellRemote.setupUtilities(self)
@@ -44,38 +66,16 @@ class B2GXPCShellRemote(XPCShellRemote):
                 print 'pushing %s' % test_file
                 self.device.pushFile(os.path.join(root, filename), test_file, retryLimit=10)
 
     # Overridden
     def pushLibs(self):
         if not self.options.use_device_libs:
             XPCShellRemote.pushLibs(self)
 
-    # Overridden
-    def setLD_LIBRARY_PATH(self, env):
-        if self.options.use_device_libs:
-            env['LD_LIBRARY_PATH'] = '/system/b2g'
-            env['LD_PRELOAD'] = '/system/b2g/libmozglue.so'
-        else:
-            XPCShellRemote.setLD_LIBRARY_PATH(self, env)
-
-    # Overridden
-    def launchProcess(self, cmd, stdout, stderr, env, cwd):
-        try:
-            # This returns 1 even when tests pass - hardcode returncode to 0 (bug 773703)
-            outputFile = XPCShellRemote.launchProcess(self, cmd, stdout, stderr, env, cwd)
-            self.shellReturnCode = 0
-        except DMError:
-            self.shellReturnCode = -1
-            outputFile = "xpcshelloutput"
-            f = open(outputFile, "a")
-            f.write("\n%s" % traceback.format_exc())
-            f.close()
-        return outputFile
-
 class B2GOptions(RemoteXPCShellOptions):
 
     def __init__(self):
         RemoteXPCShellOptions.__init__(self)
         defaults = {}
 
         self.add_option('--b2gpath', action='store',
                         type='string', dest='b2g_path',
@@ -192,16 +192,18 @@ def main():
         options.remoteTestRoot = dm.getDeviceRoot()
     xpcsh = B2GXPCShellRemote(dm, options, args)
 
     # we don't run concurrent tests on mobile
     options.sequential = True
 
     try:
         success = xpcsh.runTests(xpcshell='xpcshell', testdirs=args[0:],
+                                 testClass=B2GXPCShellTestThread,
+                                 mobileArgs=xpcsh.mobileArgs,
                                  **options.__dict__)
     except:
         print "Automation Error: Exception caught while running tests"
         traceback.print_exc()
         sys.exit(1)
 
     sys.exit(int(success))
 
diff --git a/testing/xpcshell/runxpcshelltests.py b/testing/xpcshell/runxpcshelltests.py
--- a/testing/xpcshell/runxpcshelltests.py
+++ b/testing/xpcshell/runxpcshelltests.py
@@ -942,24 +942,24 @@ class XPCShellTests(object):
 
     def addTestResults(self, test):
         self.passCount += test.passCount
         self.failCount += test.failCount
         self.todoCount += test.todoCount
         self.xunitResults.append(test.xunit_result)
 
     def runTests(self, xpcshell, xrePath=None, appPath=None, symbolsPath=None,
-                 manifest=None, testdirs=None, testPath=None,
+                 manifest=None, testdirs=None, testPath=None, mobileArgs=None,
                  interactive=False, verbose=False, keepGoing=False, logfiles=True,
                  thisChunk=1, totalChunks=1, debugger=None,
                  debuggerArgs=None, debuggerInteractive=False,
                  profileName=None, mozInfo=None, sequential=False, shuffle=False,
                  testsRootDir=None, xunitFilename=None, xunitName=None,
                  testingModulesDir=None, autolog=False, pluginsPath=None,
-                 **otherOptions):
+                 testClass=XPCShellTestThread, **otherOptions):
         """Run xpcshell tests.
 
         |xpcshell|, is the xpcshell executable to use to run the tests.
         |xrePath|, if provided, is the path to the XRE to use.
         |appPath|, if provided, is the path to an application directory.
         |symbolsPath|, if provided is the path to a directory containing
           breakpad symbols for processing crashes in tests.
         |manifest|, if provided, is a file containing a list of
@@ -1132,27 +1132,30 @@ class XPCShellTests(object):
             if self.singleFile and not name.endswith(self.singleFile):
                 continue
 
             if self.testPath and name.find(self.testPath) == -1:
                 continue
 
             self.testCount += 1
 
-            test = XPCShellTestThread(test_object, self.event, self.cleanup_dir_list,
+            test = testClass(test_object, self.event, self.cleanup_dir_list,
                     tests_root_dir=testsRootDir, app_dir_key=appDirKey,
                     interactive=interactive, verbose=verbose, pStdout=pStdout,
                     pStderr=pStderr, keep_going=keepGoing, log=self.log,
-                    **kwargs)
+                    mobileArgs=mobileArgs, **kwargs)
             if 'run-sequentially' in test_object or self.sequential:
                 sequential_tests.append(test)
             else:
                 tests_queue.append(test)
 
-        self.log.info("INFO | Using at most %d threads." % NUM_THREADS)
+        if sequential:
+            self.log.info("INFO | Running tests sequentially.")
+        else:
+            self.log.info("INFO | Using at most %d threads." % NUM_THREADS)
 
         # keep a set of NUM_THREADS running tests and start running the
         # tests in the queue at most NUM_THREADS at a time
         running_tests = set()
         keep_going = True
         exceptions = []
         tracebacks = []
         while tests_queue or running_tests:
