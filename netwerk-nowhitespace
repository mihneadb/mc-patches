Bug 888350 - use a dynamic port in network/test/unit* xpcshell tests so they can be run in parallel,r=honzab

diff --git a/netwerk/test/unit/head_cache.js b/netwerk/test/unit/head_cache.js
--- a/netwerk/test/unit/head_cache.js
+++ b/netwerk/test/unit/head_cache.js
@@ -1,8 +1,10 @@
+Components.utils.import('resource://gre/modules/XPCOMUtils.jsm');
+
 var _CSvc;
 function get_cache_service() {
   if (_CSvc)
     return _CSvc;
 
   return _CSvc = Components.classes["@mozilla.org/network/cache-service;1"]
                            .getService(Components.interfaces.nsICacheService);
 }
diff --git a/netwerk/test/unit/test_304_responses.js b/netwerk/test/unit/test_304_responses.js
--- a/netwerk/test/unit/test_304_responses.js
+++ b/netwerk/test/unit/test_304_responses.js
@@ -3,20 +3,28 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort;
+});
+
 var httpServer = null;
 const testFileName = "test_customConditionalRequest_304";
 const basePath = "/" + testFileName + "/";
-const baseURI = "http://localhost:4444" + basePath;
+
+XPCOMUtils.defineLazyGetter(this, "baseURI", function() {
+  return URL + basePath;
+});
+
 const unexpected304 = "unexpected304";
 const existingCached304 = "existingCached304";
 
 function make_uri(url) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newURI(url, null, null);
 }
@@ -41,17 +49,17 @@ function alwaysReturn304Handler(metadata
 function run_test() {
   evict_cache_entries();
 
   httpServer = new HttpServer();
   httpServer.registerPathHandler(basePath + unexpected304,
                                  alwaysReturn304Handler);
   httpServer.registerPathHandler(basePath + existingCached304,
                                  alwaysReturn304Handler);
-  httpServer.start(4444);
+  httpServer.start(-1);
   run_next_test();
 }
 
 function finish_test(request, buffer) {
   httpServer.stop(do_test_finished);
 }
 
 function consume304(request, buffer) {
diff --git a/netwerk/test/unit/test_307_redirect.js b/netwerk/test/unit/test_307_redirect.js
--- a/netwerk/test/unit/test_307_redirect.js
+++ b/netwerk/test/unit/test_307_redirect.js
@@ -1,18 +1,28 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort;
+});
+
+XPCOMUtils.defineLazyGetter(this, "uri", function() {
+  return URL + "/redirect";
+});
+
+XPCOMUtils.defineLazyGetter(this, "noRedirectURI", function() {
+  return URL + "/content";
+});
+
 var httpserver = null;
-var uri = "http://localhost:4444/redirect";
-var noRedirectURI = "http://localhost:4444/content";
 
 function make_channel(url) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 const requestBody = "request body";
@@ -64,17 +74,17 @@ function headerStreamObserver(request, b
   httpserver.stop(do_test_finished);
 }
 
 function run_test()
 {
   httpserver = new HttpServer();
   httpserver.registerPathHandler("/redirect", redirectHandler);
   httpserver.registerPathHandler("/content", contentHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   var prefs = Cc["@mozilla.org/preferences-service;1"]
                 .getService(Components.interfaces.nsIPrefBranch);
   prefs.setBoolPref("network.http.prompt-temp-redirect", false);
 
   var chan = make_channel(noRedirectURI);
   var uploadStream = Cc["@mozilla.org/io/string-input-stream;1"]
                        .createInstance(Ci.nsIStringInputStream);
diff --git a/netwerk/test/unit/test_NetUtil.js b/netwerk/test/unit/test_NetUtil.js
--- a/netwerk/test/unit/test_NetUtil.js
+++ b/netwerk/test/unit/test_NetUtil.js
@@ -195,21 +195,22 @@ function test_asyncFetch_with_nsIChannel
 
   // Start the http server, and register our handler.
   let server = new HttpServer();
   server.registerPathHandler("/test", function(aRequest, aResponse) {
     aResponse.setStatusLine(aRequest.httpVersion, 200, "OK");
     aResponse.setHeader("Content-Type", "text/plain", false);
     aResponse.write(TEST_DATA);
   });
-  server.start(4444);
+  server.start(-1);
 
   // Create our channel.
   let channel = NetUtil.ioService.
-                newChannel("http://localhost:4444/test", null, null);
+                newChannel("http://localhost:" +
+                           server.identity.primaryPort + "/test", null, null);
 
   // Open our channel asynchronously.
   NetUtil.asyncFetch(channel, function(aInputStream, aResult) {
     // Check that we had success.
     do_check_true(Components.isSuccessCode(aResult));
 
     // Check that we got the right data.
     do_check_eq(aInputStream.available(), TEST_DATA.length);
@@ -229,20 +230,21 @@ function test_asyncFetch_with_nsIURI()
 
   // Start the http server, and register our handler.
   let server = new HttpServer();
   server.registerPathHandler("/test", function(aRequest, aResponse) {
     aResponse.setStatusLine(aRequest.httpVersion, 200, "OK");
     aResponse.setHeader("Content-Type", "text/plain", false);
     aResponse.write(TEST_DATA);
   });
-  server.start(4444);
+  server.start(-1);
 
   // Create our URI.
-  let uri = NetUtil.newURI("http://localhost:4444/test");
+  let uri = NetUtil.newURI("http://localhost:" +
+                           server.identity.primaryPort + "/test");
 
   // Open our URI asynchronously.
   NetUtil.asyncFetch(uri, function(aInputStream, aResult) {
     // Check that we had success.
     do_check_true(Components.isSuccessCode(aResult));
 
     // Check that we got the right data.
     do_check_eq(aInputStream.available(), TEST_DATA.length);
@@ -262,21 +264,22 @@ function test_asyncFetch_with_string()
 
   // Start the http server, and register our handler.
   let server = new HttpServer();
   server.registerPathHandler("/test", function(aRequest, aResponse) {
     aResponse.setStatusLine(aRequest.httpVersion, 200, "OK");
     aResponse.setHeader("Content-Type", "text/plain", false);
     aResponse.write(TEST_DATA);
   });
-  server.start(4444);
+  server.start(-1);
 
   // Open our location asynchronously.
-  NetUtil.asyncFetch("http://localhost:4444/test", function(aInputStream,
-                                                            aResult) {
+  NetUtil.asyncFetch("http://localhost:" +
+                     server.identity.primaryPort + "/test",
+                     function(aInputStream, aResult) {
     // Check that we had success.
     do_check_true(Components.isSuccessCode(aResult));
 
     // Check that we got the right data.
     do_check_eq(aInputStream.available(), TEST_DATA.length);
     let is = Cc["@mozilla.org/scriptableinputstream;1"].
              createInstance(Ci.nsIScriptableInputStream);
     is.init(aInputStream);
diff --git a/netwerk/test/unit/test_XHR_redirects.js b/netwerk/test/unit/test_XHR_redirects.js
--- a/netwerk/test/unit/test_XHR_redirects.js
+++ b/netwerk/test/unit/test_XHR_redirects.js
@@ -12,18 +12,22 @@ const Cr = Components.results;
 Cu.import("resource://testing-common/httpd.js");
 
 var sSame;
 var sOther;
 
 const BUGID = "676059";
 const OTHERBUGID = "696849";
 
-const pSame = 4444;
-const pOther = 4445;
+XPCOMUtils.defineLazyGetter(this, "pSame", function() {
+  return sSame.identity.primaryPort;
+});
+XPCOMUtils.defineLazyGetter(this, "pOther", function() {
+  return sOther.identity.primaryPort;
+});
 
 function createXHR(async, method, path)
 {
   var xhr = Cc["@mozilla.org/xmlextras/xmlhttprequest;1"]
             .createInstance(Ci.nsIXMLHttpRequest);
   xhr.open(method, "http://localhost:" + pSame + path, async);
   return xhr;
 }
@@ -58,22 +62,22 @@ function run_test() {
   sSame.registerPathHandler("/bug" + OTHERBUGID + "-redirect301", bug696849redirect301);
   sSame.registerPathHandler("/bug" + OTHERBUGID + "-redirect302", bug696849redirect302);
   sSame.registerPathHandler("/bug" + OTHERBUGID + "-redirect303", bug696849redirect303);
   sSame.registerPathHandler("/bug" + OTHERBUGID + "-redirect307", bug696849redirect307);
   sSame.registerPathHandler("/bug" + OTHERBUGID + "-redirect308", bug696849redirect308);
 
   // same-origin target
   sSame.registerPathHandler("/bug" + BUGID + "-target", echoMethod);
-  sSame.start(pSame);
+  sSame.start(-1);
 
   // cross-origin target
   sOther = new HttpServer();
   sOther.registerPathHandler("/bug" + OTHERBUGID + "-target", echoMethod);
-  sOther.start(pOther);
+  sOther.start(-1);
 
   // format: redirectType, methodToSend, redirectedMethod, finalStatus
   //   redirectType sets the URI the initial request goes to
   //   methodToSend is the HTTP method to send
   //   redirectedMethod is the method to use for the redirect, if any
   //   finalStatus is 200 when the redirect takes place, redirectType otherwise
   
   // Note that unsafe methods should not follow the redirect automatically
diff --git a/netwerk/test/unit/test_assoc.js b/netwerk/test/unit/test_assoc.js
--- a/netwerk/test/unit/test_assoc.js
+++ b/netwerk/test/unit/test_assoc.js
@@ -2,50 +2,61 @@ const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpserver = new HttpServer();
 var currentTestIndex = 0;
-var tests = [
-             // this is valid
-             {url: "/assoc/assoctest?valid",
-              responseheader: [ "Assoc-Req: GET http://localhost:4444/assoc/assoctest?valid",
-                                "Pragma: X-Verify-Assoc-Req" ],
-              flags : 0},
 
-             // this is invalid because the method is wrong
-             {url: "/assoc/assoctest?invalid",
-              responseheader: [ "Assoc-Req: POST http://localhost:4444/assoc/assoctest?invalid",
-                                "Pragma: X-Verify-Assoc-Req" ],
-              flags : CL_EXPECT_LATE_FAILURE},
-             
-             // this is invalid because the url is wrong
-             {url: "/assoc/assoctest?notvalid",
-              responseheader: [ "Assoc-Req: GET http://localhost:4444/wrongpath/assoc/assoctest?notvalid",
-                                "Pragma: X-Verify-Assoc-Req" ],
-              flags : CL_EXPECT_LATE_FAILURE},
+XPCOMUtils.defineLazyGetter(this, "port", function() {
+    return httpserver.identity.primaryPort;
+});
+
+XPCOMUtils.defineLazyGetter(this, "tests", function() {
+    return [
+            // this is valid
+            {url: "/assoc/assoctest?valid",
+             responseheader: ["Assoc-Req: GET http://localhost:" + port +
+                              "/assoc/assoctest?valid",
+                              "Pragma: X-Verify-Assoc-Req"],
+             flags: 0},
+
+            // this is invalid because the method is wrong
+            {url: "/assoc/assoctest?invalid",
+             responseheader: ["Assoc-Req: POST http://localhost:" + port +
+                              "/assoc/assoctest?invalid",
+                              "Pragma: X-Verify-Assoc-Req"],
+             flags: CL_EXPECT_LATE_FAILURE},
+
+            // this is invalid because the url is wrong
+            {url: "/assoc/assoctest?notvalid",
+             responseheader: ["Assoc-Req: GET http://localhost:" + port +
+                              "/wrongpath/assoc/assoctest?notvalid",
+                              "Pragma: X-Verify-Assoc-Req"],
+             flags: CL_EXPECT_LATE_FAILURE},
 
              // this is invalid because the space between method and URL is missing
-             {url: "/assoc/assoctest?invalid2",
-              responseheader: [ "Assoc-Req: GEThttp://localhost:4444/assoc/assoctest?invalid2",
-                                "Pragma: X-Verify-Assoc-Req" ],
-              flags : CL_EXPECT_LATE_FAILURE},
-];
+            {url: "/assoc/assoctest?invalid2",
+             responseheader: ["Assoc-Req: GEThttp://localhost:" + port +
+                              "/assoc/assoctest?invalid2",
+                              "Pragma: X-Verify-Assoc-Req"],
+             flags: CL_EXPECT_LATE_FAILURE},
+    ];
+});
 
 var oldPrefVal;
 var domBranch;
 
 function setupChannel(url)
 {
     var ios = Components.classes["@mozilla.org/network/io-service;1"].
                          getService(Ci.nsIIOService);
-    var chan = ios.newChannel("http://localhost:4444" + url, "", null);
+    var chan = ios.newChannel("http://localhost:" + port + url, "", null);
     return chan;
 }
 
 function startIter()
 {
     var channel = setupChannel(tests[currentTestIndex].url);
     channel.asyncOpen(new ChannelListener(completeIter,
                                           channel, tests[currentTestIndex].flags), null);
@@ -66,17 +77,17 @@ function run_test()
     var prefService =
         Components.classes["@mozilla.org/preferences-service;1"]
         .getService(Components.interfaces.nsIPrefService);
     domBranch = prefService.getBranch("network.http.assoc-req.");
     oldPrefVal = domBranch.getBoolPref("enforce");
     domBranch.setBoolPref("enforce", true);
 
     httpserver.registerPathHandler("/assoc/assoctest", handler);
-    httpserver.start(4444);
+    httpserver.start(-1);
 
     startIter();
     do_test_pending();
 }
 
 function handler(metadata, response)
 {
     var body = "thequickbrownfox";
diff --git a/netwerk/test/unit/test_auth_proxy.js b/netwerk/test/unit/test_auth_proxy.js
--- a/netwerk/test/unit/test_auth_proxy.js
+++ b/netwerk/test/unit/test_auth_proxy.js
@@ -221,22 +221,22 @@ function makeChan(url) {
 
 var current_test = 0;
 var httpserv = null;
 
 function run_test() {
   httpserv = new HttpServer();
   httpserv.registerPathHandler("/", proxyAuthHandler);
   httpserv.identity.add("http", "somesite", 80);
-  httpserv.start(4444);
+  httpserv.start(-1);
 
   const prefs = Cc["@mozilla.org/preferences-service;1"]
                          .getService(Ci.nsIPrefBranch);
   prefs.setCharPref("network.proxy.http", "localhost");
-  prefs.setIntPref("network.proxy.http_port", 4444);
+  prefs.setIntPref("network.proxy.http_port", httpserv.identity.primaryPort);
   prefs.setCharPref("network.proxy.no_proxies_on", "");
   prefs.setIntPref("network.proxy.type", 1);
 
   tests[current_test]();
 }
 
 function test_proxy_returnfalse() {
   dump("\ntest: proxy returnfalse\n");
diff --git a/netwerk/test/unit/test_authentication.js b/netwerk/test/unit/test_authentication.js
--- a/netwerk/test/unit/test_authentication.js
+++ b/netwerk/test/unit/test_authentication.js
@@ -3,16 +3,24 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserv.identity.primaryPort;
+});
+
+XPCOMUtils.defineLazyGetter(this, "PORT", function() {
+  return httpserv.identity.primaryPort;
+});
+
 const FLAG_RETURN_FALSE   = 1 << 0;
 const FLAG_WRONG_PASSWORD = 1 << 1;
 const FLAG_BOGUS_USER = 1 << 2;
 const FLAG_PREVIOUS_FAILED = 1 << 3;
 
 const nsIAuthPrompt2 = Components.interfaces.nsIAuthPrompt2;
 const nsIAuthInformation = Components.interfaces.nsIAuthInformation;
 
@@ -37,22 +45,22 @@ AuthPrompt1.prototype = {
   prompt: function ap1_prompt(title, text, realm, save, defaultText, result) {
     do_throw("unexpected prompt call");
   },
 
   promptUsernameAndPassword:
     function ap1_promptUP(title, text, realm, savePW, user, pw)
   {
     // Note that the realm here isn't actually the realm. it's a pw mgr key.
-    do_check_eq("http://localhost:4444 (" + this.expectedRealm + ")", realm);
+    do_check_eq(URL + " (" + this.expectedRealm + ")", realm);
     if (text.indexOf(this.expectedRealm) == -1)
       do_throw("Text must indicate the realm");
     if (text.indexOf("localhost") == -1)
       do_throw("Text must indicate the hostname");
-    if (text.indexOf("4444") == -1)
+    if (text.indexOf(String(PORT)) == -1)
       do_throw("Text must indicate the port");
     if (text.indexOf("-1") != -1)
       do_throw("Text must contain negative numbers");
 
     if (this.flags & FLAG_RETURN_FALSE)
       return false;
 
     if (this.flags & FLAG_BOGUS_USER)
@@ -286,132 +294,132 @@ var httpserv = null;
 function run_test() {
   httpserv = new HttpServer();
 
   httpserv.registerPathHandler("/auth", authHandler);
   httpserv.registerPathHandler("/auth/ntlm/simple", authNtlmSimple);
   httpserv.registerPathHandler("/auth/realm", authRealm);
   httpserv.registerPathHandler("/auth/digest", authDigest);
 
-  httpserv.start(4444);
+  httpserv.start(-1);
 
   tests[0]();
 }
 
 function test_noauth() {
-  var chan = makeChan("http://localhost:4444/auth");
+  var chan = makeChan(URL + "/auth");
 
   listener.expectedCode = 401; // Unauthorized
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 function test_returnfalse1() {
-  var chan = makeChan("http://localhost:4444/auth");
+  var chan = makeChan(URL + "/auth");
 
   chan.notificationCallbacks = new Requestor(FLAG_RETURN_FALSE, 1);
   listener.expectedCode = 401; // Unauthorized
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 function test_wrongpw1() {
-  var chan = makeChan("http://localhost:4444/auth");
+  var chan = makeChan(URL + "/auth");
 
   chan.notificationCallbacks = new Requestor(FLAG_WRONG_PASSWORD, 1);
   listener.expectedCode = 200; // OK
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 function test_prompt1() {
-  var chan = makeChan("http://localhost:4444/auth");
+  var chan = makeChan(URL + "/auth");
 
   chan.notificationCallbacks = new Requestor(0, 1);
   listener.expectedCode = 200; // OK
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 function test_returnfalse2() {
-  var chan = makeChan("http://localhost:4444/auth");
+  var chan = makeChan(URL + "/auth");
 
   chan.notificationCallbacks = new Requestor(FLAG_RETURN_FALSE, 2);
   listener.expectedCode = 401; // Unauthorized
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 function test_wrongpw2() {
-  var chan = makeChan("http://localhost:4444/auth");
+  var chan = makeChan(URL + "/auth");
 
   chan.notificationCallbacks = new Requestor(FLAG_WRONG_PASSWORD, 2);
   listener.expectedCode = 200; // OK
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 function test_prompt2() {
-  var chan = makeChan("http://localhost:4444/auth");
+  var chan = makeChan(URL + "/auth");
 
   chan.notificationCallbacks = new Requestor(0, 2);
   listener.expectedCode = 200; // OK
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 function test_ntlm() {
-  var chan = makeChan("http://localhost:4444/auth/ntlm/simple");
+  var chan = makeChan(URL + "/auth/ntlm/simple");
 
   chan.notificationCallbacks = new Requestor(FLAG_RETURN_FALSE, 2);
   listener.expectedCode = 401; // Unauthorized
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 function test_auth() {
-  var chan = makeChan("http://localhost:4444/auth/realm");
+  var chan = makeChan(URL + "/auth/realm");
 
   chan.notificationCallbacks = new RealmTestRequestor();
   listener.expectedCode = 401; // Unauthorized
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 function test_digest_noauth() {
-  var chan = makeChan("http://localhost:4444/auth/digest");
+  var chan = makeChan(URL + "/auth/digest");
 
   //chan.notificationCallbacks = new Requestor(FLAG_RETURN_FALSE, 2);
   listener.expectedCode = 401; // Unauthorized
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 function test_digest() {
-  var chan = makeChan("http://localhost:4444/auth/digest");
+  var chan = makeChan(URL + "/auth/digest");
 
   chan.notificationCallbacks = new Requestor(0, 2);
   listener.expectedCode = 200; // OK
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 function test_digest_bogus_user() {
-  var chan = makeChan("http://localhost:4444/auth/digest");
+  var chan = makeChan(URL + "/auth/digest");
   chan.notificationCallbacks =  new Requestor(FLAG_BOGUS_USER, 2);
   listener.expectedCode = 401; // unauthorized
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 // PATH HANDLERS
diff --git a/netwerk/test/unit/test_bug203271.js b/netwerk/test/unit/test_bug203271.js
--- a/netwerk/test/unit/test_bug203271.js
+++ b/netwerk/test/unit/test_bug203271.js
@@ -96,17 +96,19 @@ function logit(i, data, ctx) {
         }}
     );
     dump("===================================\n")
 }
 
 function setupChannel(suffix, value) {
     var ios = Components.classes["@mozilla.org/network/io-service;1"].
                          getService(Ci.nsIIOService);
-    var chan = ios.newChannel("http://localhost:4444" + suffix, "", null);
+    var chan = ios.newChannel("http://localhost:" +
+                              httpserver.identity.primaryPort + suffix,
+                              "", null);
     var httpChan = chan.QueryInterface(Components.interfaces.nsIHttpChannel);
     httpChan.requestMethod = "GET"; // default value, just being paranoid...
     httpChan.setRequestHeader("x-request", value, false);
     return httpChan;
 }
 
 function triggerNextTest() {
     var channel = setupChannel(tests[index].url, tests[index].server);
@@ -126,17 +128,17 @@ function checkValueAndTrigger(request, d
         }
     } else {
         httpserver.stop(do_test_finished);
     }
 }
 
 function run_test() {
     httpserver.registerPathHandler("/precedence", handler);
-    httpserver.start(4444);
+    httpserver.start(-1);
 
     // clear cache
     evict_cache_entries();
 
     triggerNextTest();
     do_test_pending();
 }
 
diff --git a/netwerk/test/unit/test_bug248970_cookie.js b/netwerk/test/unit/test_bug248970_cookie.js
--- a/netwerk/test/unit/test_bug248970_cookie.js
+++ b/netwerk/test/unit/test_bug248970_cookie.js
@@ -13,17 +13,17 @@ var httpserver;
 
 function inChildProcess() {
   return Cc["@mozilla.org/xre/app-info;1"]
            .getService(Ci.nsIXULRuntime)
            .processType != Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT;  
 }
 function makeChan(path) {
   var ios = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
-  var chan = ios.newChannel("http://localhost:4444/" + path, null, null)
+  var chan = ios.newChannel("http://localhost:" + httpserver.identity.primaryPort + "/" + path, null, null)
                 .QueryInterface(Ci.nsIHttpChannel);
   return chan;
 }
 
 function setup_chan(path, isPrivate, callback) {
   var chan = makeChan(path);
   chan.QueryInterface(Ci.nsIPrivateBrowsingChannel).setPrivate(isPrivate);
   chan.asyncOpen(new ChannelListener(callback), null);  
@@ -68,17 +68,17 @@ function setHandler(metadata, response) 
 function run_test() {
   // Allow all cookies if the pref service is available in this process.
   if (!inChildProcess())
     Services.prefs.setIntPref("network.cookie.cookieBehavior", 0);
 
   httpserver = new HttpServer();
   httpserver.registerPathHandler("/set", setHandler);
   httpserver.registerPathHandler("/present", presentHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
   
   do_test_pending();
   
   function check_cookie(req) {
     req.QueryInterface(Ci.nsIHttpChannel);
     do_check_eq(req.responseStatus, 200);
     try {
       do_check_true(req.getResponseHeader("Set-Cookie") != "", "expected a Set-Cookie header");
diff --git a/netwerk/test/unit/test_bug263127.js b/netwerk/test/unit/test_bug263127.js
--- a/netwerk/test/unit/test_bug263127.js
+++ b/netwerk/test/unit/test_bug263127.js
@@ -35,22 +35,23 @@ var listener = {
 
     do_test_finished();
   }
 }
 
 function run_test() {
   // start server
   server = new HttpServer();
-  server.start(4444);
+  server.start(-1);
 
   // Initialize downloader
   var channel = Cc["@mozilla.org/network/io-service;1"]
                   .getService(Ci.nsIIOService)
-                  .newChannel("http://localhost:4444/", null, null);
+                  .newChannel("http://localhost:" +
+                              server.identity.primaryPort + "/", null, null);
 
   var targetFile = Cc["@mozilla.org/file/directory_service;1"]
                      .getService(Ci.nsIProperties)
                      .get("TmpD", Ci.nsIFile);
   targetFile.append("bug" + BUGID + ".test");
   if (targetFile.exists())
     targetFile.remove(false);
 
diff --git a/netwerk/test/unit/test_bug331825.js b/netwerk/test/unit/test_bug331825.js
--- a/netwerk/test/unit/test_bug331825.js
+++ b/netwerk/test/unit/test_bug331825.js
@@ -20,23 +20,24 @@ TestListener.prototype.onStopRequest = f
 }
 
 function run_test() {
   // start server
   server = new HttpServer();
 
   server.registerPathHandler("/bug" + BUGID, bug331825);
 
-  server.start(4444);
+  server.start(-1);
 
   // make request
   var channel =
       Components.classes["@mozilla.org/network/io-service;1"].
       getService(Components.interfaces.nsIIOService).
-      newChannel("http://localhost:4444/bug" + BUGID, null, null);
+      newChannel("http://localhost:" + server.identity.primaryPort + "/bug" +
+                 BUGID, null, null);
 
   channel.QueryInterface(Components.interfaces.nsIHttpChannel);
   channel.setRequestHeader("If-None-Match", "foobar", false);
   channel.asyncOpen(new TestListener(), null);
 
   do_test_pending();
 }
 
diff --git a/netwerk/test/unit/test_bug369787.js b/netwerk/test/unit/test_bug369787.js
--- a/netwerk/test/unit/test_bug369787.js
+++ b/netwerk/test/unit/test_bug369787.js
@@ -51,23 +51,24 @@ function after_channel_closed() {
 }
 
 function run_test() {
   // start server
   server = new HttpServer();
 
   server.registerPathHandler("/bug" + BUGID, bug369787);
 
-  server.start(4444);
+  server.start(-1);
 
   // make request
   channel =
       Components.classes["@mozilla.org/network/io-service;1"].
       getService(Components.interfaces.nsIIOService).
-      newChannel("http://localhost:4444/bug" + BUGID, null, null);
+      newChannel("http://localhost:" +
+                 server.identity.primaryPort + "/bug" + BUGID, null, null);
 
   channel.QueryInterface(Components.interfaces.nsIHttpChannel);
   channel.asyncOpen(new TestListener(), null);
 
   do_test_pending();
 }
 
 // PATH HANDLER FOR /bug369787
diff --git a/netwerk/test/unit/test_bug412945.js b/netwerk/test/unit/test_bug412945.js
--- a/netwerk/test/unit/test_bug412945.js
+++ b/netwerk/test/unit/test_bug412945.js
@@ -17,23 +17,24 @@ TestListener.prototype.onStopRequest = f
   httpserv.stop(do_test_finished);
 }
 
 function run_test() {
   httpserv = new HttpServer();
 
   httpserv.registerPathHandler("/bug412945", bug412945);
 
-  httpserv.start(4444);
+  httpserv.start(-1);
 
   // make request
   var channel =
       Components.classes["@mozilla.org/network/io-service;1"].
       getService(Components.interfaces.nsIIOService).
-      newChannel("http://localhost:4444/bug412945", null, null);
+      newChannel("http://localhost:" + httpserv.identity.primaryPort +
+                 "/bug412945", null, null);
 
   channel.QueryInterface(Components.interfaces.nsIHttpChannel);
   channel.requestMethod = "post";
   channel.asyncOpen(new TestListener(), null);
 
   do_test_pending();
 }
 
diff --git a/netwerk/test/unit/test_bug468426.js b/netwerk/test/unit/test_bug468426.js
--- a/netwerk/test/unit/test_bug468426.js
+++ b/netwerk/test/unit/test_bug468426.js
@@ -35,17 +35,18 @@ var tests = [
     // no cookie in the request we expect a fresh value
     { url : "/bug468426", server : "6", expected : "6", cookie: null},
 
 ];
 
 function setupChannel(suffix, value, cookie) {
     var ios = Components.classes["@mozilla.org/network/io-service;1"]
             .getService(Ci.nsIIOService);
-    var chan = ios.newChannel("http://localhost:4444" + suffix, "", null);
+    var chan = ios.newChannel("http://localhost:" +
+                             httpserver.identity.primaryPort + suffix, "", null);
     var httpChan = chan.QueryInterface(Components.interfaces.nsIHttpChannel);
     httpChan.requestMethod = "GET";
     httpChan.setRequestHeader("x-request", value, false);
     if (cookie != null)
         httpChan.setRequestHeader("Cookie", cookie, false);
     return httpChan;
 }
 
@@ -64,17 +65,17 @@ function checkValueAndTrigger(request, d
         do_timeout(1, triggerNextTest);
     } else {
         httpserver.stop(do_test_finished);
     }
 }
 
 function run_test() {
     httpserver.registerPathHandler("/bug468426", handler);
-    httpserver.start(4444);
+    httpserver.start(-1);
 
     // Clear cache and trigger the first test
     evict_cache_entries();
     triggerNextTest();
 
     do_test_pending();
 }
 
diff --git a/netwerk/test/unit/test_bug468594.js b/netwerk/test/unit/test_bug468594.js
--- a/netwerk/test/unit/test_bug468594.js
+++ b/netwerk/test/unit/test_bug468594.js
@@ -57,17 +57,17 @@ function logit(i, data) {
     if (tests[i].responseheader)
         dump("\t[" + tests[i].responseheader + "]");
     dump("\n");
 }
 
 function setupChannel(suffix, value) {
     var ios = Components.classes["@mozilla.org/network/io-service;1"].
                          getService(Ci.nsIIOService);
-    var chan = ios.newChannel("http://localhost:4444" + suffix, "", null);
+    var chan = ios.newChannel("http://localhost:" + httpserver.identity.primaryPort + suffix, "", null);
     var httpChan = chan.QueryInterface(Components.interfaces.nsIHttpChannel);
     httpChan.requestMethod = "GET";
     httpChan.setRequestHeader("x-request", value, false);
     return httpChan;
 }
 
 function triggerNextTest() {
     var channel = setupChannel(tests[index].url, tests[index].server);
@@ -83,17 +83,17 @@ function checkValueAndTrigger(request, d
         triggerNextTest();
     } else {
         httpserver.stop(do_test_finished);
     }
 }
 
 function run_test() {
     httpserver.registerPathHandler("/freshness", handler);
-    httpserver.start(4444);
+    httpserver.start(-1);
 
     // clear cache
     evict_cache_entries();
     triggerNextTest();
 
     do_test_pending();
 }
 
diff --git a/netwerk/test/unit/test_bug482601.js b/netwerk/test/unit/test_bug482601.js
--- a/netwerk/test/unit/test_bug482601.js
+++ b/netwerk/test/unit/test_bug482601.js
@@ -45,17 +45,17 @@ var listener = {
 };
 
 function run_test() {
   httpserv = new HttpServer();
   httpserv.registerPathHandler("/bug482601/nocache", bug482601_nocache);
   httpserv.registerPathHandler("/bug482601/partial", bug482601_partial);
   httpserv.registerPathHandler("/bug482601/cached", bug482601_cached);
   httpserv.registerPathHandler("/bug482601/only_from_cache", bug482601_only_from_cache);
-  httpserv.start(4444);
+  httpserv.start(-1);
 
   var obs = Cc["@mozilla.org/observer-service;1"].getService();
   obs = obs.QueryInterface(Ci.nsIObserverService);
   obs.addObserver(observer, "http-on-examine-response", false);
   obs.addObserver(observer, "http-on-examine-merged-response", false);
   obs.addObserver(observer, "http-on-examine-cached-response", false);
 
   do_timeout(0, do_test);
@@ -102,22 +102,24 @@ function storeCache(aCacheEntry, aRespon
   }
   oStream.close();
   aCacheEntry.close();
 }
 
 function test_nocache() {
   observers_called = "";
 
-  var chan = makeChan("http://localhost:4444/bug482601/nocache");
+  var chan = makeChan("http://localhost:" + httpserv.identity.primaryPort +
+                      "/bug482601/nocache");
   chan.asyncOpen(listener, null);
 }
 
 function test_partial() {
-   asyncOpenCacheEntry("http://localhost:4444/bug482601/partial",
+   asyncOpenCacheEntry("http://localhost:" + httpserv.identity.primaryPort +
+                       "/bug482601/partial",
                        "HTTP",
                        Ci.nsICache.STORE_ANYWHERE,
                        Ci.nsICache.ACCESS_READ_WRITE,
                        test_partial2);
 }
 
 function test_partial2(status, entry) {
   do_check_eq(status, Cr.NS_OK);
@@ -128,22 +130,24 @@ function test_partial2(status, entry) {
              "Last-Modified: Thu, 1 Jan 2009 00:00:00 GMT\r\n" +
              "Accept-Ranges: bytes\r\n" +
              "Content-Length: 10\r\n" +
              "Content-Type: text/plain\r\n",
              "0123");
 
   observers_called = "";
 
-  var chan = makeChan("http://localhost:4444/bug482601/partial");
+  var chan = makeChan("http://localhost:" + httpserv.identity.primaryPort +
+                      "/bug482601/partial");
   chan.asyncOpen(listener, null);
 }
 
 function test_cached() {
-   asyncOpenCacheEntry("http://localhost:4444/bug482601/cached",
+   asyncOpenCacheEntry("http://localhost:" + httpserv.identity.primaryPort +
+                       "/bug482601/cached",
                        "HTTP",
                        Ci.nsICache.STORE_ANYWHERE,
                        Ci.nsICache.ACCESS_READ_WRITE,
                        test_cached2);
 }
 
 function test_cached2(status, entry) {
   do_check_eq(status, Cr.NS_OK);
@@ -154,23 +158,25 @@ function test_cached2(status, entry) {
              "Last-Modified: Thu, 1 Jan 2009 00:00:00 GMT\r\n" +
              "Accept-Ranges: bytes\r\n" +
              "Content-Length: 10\r\n" +
              "Content-Type: text/plain\r\n",
              "0123456789");
 
   observers_called = "";
 
-  var chan = makeChan("http://localhost:4444/bug482601/cached");
+  var chan = makeChan("http://localhost:" + httpserv.identity.primaryPort +
+                      "/bug482601/cached");
   chan.loadFlags = Ci.nsIRequest.VALIDATE_ALWAYS;
   chan.asyncOpen(listener, null);
 }
 
 function test_only_from_cache() {
-   asyncOpenCacheEntry("http://localhost:4444/bug482601/only_from_cache",
+   asyncOpenCacheEntry("http://localhost:" + httpserv.identity.primaryPort +
+                       "/bug482601/only_from_cache",
                        "HTTP",
                        Ci.nsICache.STORE_ANYWHERE,
                        Ci.nsICache.ACCESS_READ_WRITE,
                        test_only_from_cache2);
 }
 
 function test_only_from_cache2(status, entry) {
   do_check_eq(status, Cr.NS_OK);
@@ -181,17 +187,18 @@ function test_only_from_cache2(status, e
              "Last-Modified: Thu, 1 Jan 2009 00:00:00 GMT\r\n" +
              "Accept-Ranges: bytes\r\n" +
              "Content-Length: 10\r\n" +
              "Content-Type: text/plain\r\n",
              "0123456789");
 
   observers_called = "";
 
-  var chan = makeChan("http://localhost:4444/bug482601/only_from_cache");
+  var chan = makeChan("http://localhost:" + httpserv.identity.primaryPort +
+                      "/bug482601/only_from_cache");
   chan.loadFlags = Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE;
   chan.asyncOpen(listener, null);
 }
 
 
 // PATHS
 
 // /bug482601/nocache
diff --git a/netwerk/test/unit/test_bug490095.js b/netwerk/test/unit/test_bug490095.js
--- a/netwerk/test/unit/test_bug490095.js
+++ b/netwerk/test/unit/test_bug490095.js
@@ -44,17 +44,19 @@ function logit(i, data) {
     if (tests[i].responseheader)
         dump("\t[" + tests[i].responseheader + "]");
     dump("\n");
 }
 
 function setupChannel(suffix, value) {
     var ios = Components.classes["@mozilla.org/network/io-service;1"].
                          getService(Ci.nsIIOService);
-    var chan = ios.newChannel("http://localhost:4444" + suffix, "", null);
+    var chan = ios.newChannel("http://localhost:" +
+                              httpserver.identity.primaryPort +
+                              suffix, "", null);
     var httpChan = chan.QueryInterface(Components.interfaces.nsIHttpChannel);
     httpChan.requestMethod = "GET";
     httpChan.setRequestHeader("x-request", value, false);
     return httpChan;
 }
 
 function triggerNextTest() {
     var test = tests[index];
@@ -74,17 +76,17 @@ function checkValueAndTrigger(request, d
         do_timeout(1, triggerNextTest);
     } else {
         httpserver.stop(do_test_finished);
     }
 }
 
 function run_test() {
     httpserver.registerPathHandler("/freshness", handler);
-    httpserver.start(4444);
+    httpserver.start(-1);
 
     // clear cache
     evict_cache_entries();
 
     triggerNextTest();
 
     do_test_pending();
 }
diff --git a/netwerk/test/unit/test_bug510359.js b/netwerk/test/unit/test_bug510359.js
--- a/netwerk/test/unit/test_bug510359.js
+++ b/netwerk/test/unit/test_bug510359.js
@@ -10,17 +10,19 @@ var index = 0;
 var tests = [
     { url : "/bug510359", server : "0", expected : "0"},
     { url : "/bug510359", server : "1", expected : "1"},
 ];
 
 function setupChannel(suffix, value) {
     var ios = Components.classes["@mozilla.org/network/io-service;1"]
             .getService(Ci.nsIIOService);
-    var chan = ios.newChannel("http://localhost:4444" + suffix, "", null);
+    var chan = ios.newChannel("http://localhost:" +
+                              httpserver.identity.primaryPort +
+                              suffix, "", null);
     var httpChan = chan.QueryInterface(Components.interfaces.nsIHttpChannel);
     httpChan.requestMethod = "GET";
     httpChan.setRequestHeader("x-request", value, false);
     httpChan.setRequestHeader("Cookie", "c="+value, false);
     return httpChan;
 }
 
 function triggerNextTest() {
@@ -36,17 +38,17 @@ function checkValueAndTrigger(request, d
         triggerNextTest();
     } else {
         httpserver.stop(do_test_finished);
     }
 }
 
 function run_test() {
     httpserver.registerPathHandler("/bug510359", handler);
-    httpserver.start(4444);
+    httpserver.start(-1);
 
     // clear cache
     evict_cache_entries();
 
     triggerNextTest();
 
     do_test_pending();
 }
diff --git a/netwerk/test/unit/test_bug528292.js b/netwerk/test/unit/test_bug528292.js
--- a/netwerk/test/unit/test_bug528292.js
+++ b/netwerk/test/unit/test_bug528292.js
@@ -2,21 +2,33 @@ const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 const sentCookieVal     = "foo=bar";
 const responseBody      = "response body";
-const baseURL           = "http://localhost:4444";
+
+XPCOMUtils.defineLazyGetter(this, "baseURL", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort;
+});
+
 const preRedirectPath   = "/528292/pre-redirect";
-const preRedirectURL    = baseURL + preRedirectPath;
+
+XPCOMUtils.defineLazyGetter(this, "preRedirectURL", function() {
+  return baseURL + preRedirectPath;
+});
+
 const postRedirectPath  = "/528292/post-redirect";
-const postRedirectURL   = baseURL + postRedirectPath;
+
+XPCOMUtils.defineLazyGetter(this, "postRedirectURL", function() {
+  return baseURL + postRedirectPath;
+});
+
 var   httpServer        = null;
 var   receivedCookieVal = null;
 
 function preRedirectHandler(metadata, response)
 {
   response.setStatusLine(metadata.httpVersion, 302, "Found");
   response.setHeader("Location", postRedirectURL, false);
   return;
@@ -30,17 +42,17 @@ function postRedirectHandler(metadata, r
 }
 
 function run_test()
 {
   // Start the HTTP server.
   httpServer = new HttpServer();
   httpServer.registerPathHandler(preRedirectPath, preRedirectHandler);
   httpServer.registerPathHandler(postRedirectPath, postRedirectHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   // Disable third-party cookies in general.
   Cc["@mozilla.org/preferences-service;1"].getService(Ci.nsIPrefBranch).
     setIntPref("network.cookie.cookieBehavior", 1);
 
   var ioService = Cc["@mozilla.org/network/io-service;1"].
                   getService(Ci.nsIIOService);
 
diff --git a/netwerk/test/unit/test_bug536324_64bit_content_length.js b/netwerk/test/unit/test_bug536324_64bit_content_length.js
--- a/netwerk/test/unit/test_bug536324_64bit_content_length.js
+++ b/netwerk/test/unit/test_bug536324_64bit_content_length.js
@@ -46,21 +46,22 @@ function hugeContentLength(metadata, res
     bytes_written += text.length;
   }
 
   response.finish();
 }
 
 function test_hugeContentLength() {
   var ios = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
-  var chan = ios.newChannel("http://localhost:4444/", null, null)
+  var chan = ios.newChannel("http://localhost:" +
+                            httpServer.identity.primaryPort + "/", null, null)
                 .QueryInterface(Ci.nsIHttpChannel);
   chan.asyncOpen(listener, null);
 }
 
 add_test(test_hugeContentLength);
 
 function run_test() {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/", hugeContentLength);
-  httpServer.start(4444);
+  httpServer.start(-1);
   run_next_test();
 }
diff --git a/netwerk/test/unit/test_bug561276.js b/netwerk/test/unit/test_bug561276.js
--- a/netwerk/test/unit/test_bug561276.js
+++ b/netwerk/test/unit/test_bug561276.js
@@ -13,33 +13,34 @@ Cu.import("resource://testing-common/htt
 var httpserver = new HttpServer();
 var iteration = 0;
 
 function setupChannel(suffix)
 {
     var ios =
         Components.classes["@mozilla.org/network/io-service;1"]
         .getService(Ci.nsIIOService);
-    var chan = ios.newChannel("http://localhost:4444" + suffix, "", null);
+    var chan = ios.newChannel("http://localhost:" +
+			     httpserver.identity.primaryPort + suffix, "", null);
     var httpChan = chan.QueryInterface(Components.interfaces.nsIHttpChannel);
     httpChan.requestMethod = "GET";
     return httpChan;
 }
 
 function checkValueAndTrigger(request, data, ctx)
 {
     do_check_eq("Ok", data);
     httpserver.stop(do_test_finished);
 }
 
 function run_test()
 {
     httpserver.registerPathHandler("/redirect1", redirectHandler1);
     httpserver.registerPathHandler("/redirect2", redirectHandler2);
-    httpserver.start(4444);
+    httpserver.start(-1);
 
     // clear cache
     evict_cache_entries();
 
     // load first time
     var channel = setupChannel("/redirect1");
     channel.asyncOpen(new ChannelListener(checkValueAndTrigger, null), null);
 
diff --git a/netwerk/test/unit/test_bug586908.js b/netwerk/test/unit/test_bug586908.js
--- a/netwerk/test/unit/test_bug586908.js
+++ b/netwerk/test/unit/test_bug586908.js
@@ -5,39 +5,41 @@ const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpserv = null;
 
 const CID = Components.ID("{5645d2c1-d6d8-4091-b117-fe7ee4027db7}");
 const contractID = "@mozilla.org/system-proxy-settings;1"
 
-var systemSettings = {
-  QueryInterface: function (iid) {
-    if (iid.equals(Components.interfaces.nsISupports) ||
-        iid.equals(Components.interfaces.nsIFactory) ||
-        iid.equals(Components.interfaces.nsISystemProxySettings))
-      return this;
-    throw Components.results.NS_ERROR_NO_INTERFACE;
-  },
-  createInstance: function (outer, iid) {
-    if (outer)
-      throw Components.results.NS_ERROR_NO_AGGREGATION;
-    return this.QueryInterface(iid);
-  },
-  lockFactory: function (lock) {
-    throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-  },
-  
-  mainThreadOnly: true,
-  PACURI: "http://localhost:4444/redirect",
-  getProxyForURI: function(aURI) {
-    throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-  }
-};
+XPCOMUtils.defineLazyGetter(this, "systemSettings", function() {
+  return {
+    QueryInterface: function (iid) {
+      if (iid.equals(Components.interfaces.nsISupports) ||
+          iid.equals(Components.interfaces.nsIFactory) ||
+          iid.equals(Components.interfaces.nsISystemProxySettings))
+        return this;
+      throw Components.results.NS_ERROR_NO_INTERFACE;
+    },
+    createInstance: function (outer, iid) {
+      if (outer)
+        throw Components.results.NS_ERROR_NO_AGGREGATION;
+      return this.QueryInterface(iid);
+    },
+    lockFactory: function (lock) {
+      throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
+    },
+
+    mainThreadOnly: true,
+    PACURI: "http://localhost:" + httpserv.identity.primaryPort + "/redirect",
+    getProxyForURI: function(aURI) {
+      throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
+    }
+  };
+});
 
 function checkValue(request, data, ctx) {
   do_check_true(called);
   do_check_eq("ok", data);
   httpserv.stop(do_test_finished);
 }
 
 function makeChan(url) {
@@ -49,34 +51,35 @@ function makeChan(url) {
   return chan;
 }
 
 function run_test() {
   httpserv = new HttpServer();
   httpserv.registerPathHandler("/redirect", redirect);
   httpserv.registerPathHandler("/pac", pac);
   httpserv.registerPathHandler("/target", target);
-  httpserv.start(4444);
+  httpserv.start(-1);
 
   Components.manager.nsIComponentRegistrar.registerFactory(
     CID,
     "Fake system proxy-settings",
     contractID, systemSettings);
 
   // Ensure we're using system-properties
   const prefs = Cc["@mozilla.org/preferences-service;1"]
                    .getService(Ci.nsIPrefBranch);
   prefs.setIntPref(
     "network.proxy.type",
     Components.interfaces.nsIProtocolProxyService.PROXYCONFIG_SYSTEM);
 
   // clear cache
   evict_cache_entries();
 
-  var chan = makeChan("http://localhost:4444/target");
+  var chan = makeChan("http://localhost:" + httpserv.identity.primaryPort +
+                      "/target");
   chan.asyncOpen(new ChannelListener(checkValue, null), null);
 
   do_test_pending();
 }
 
 var called = false, failed = false;
 function redirect(metadata, response) {
   // If called second time, just return the PAC but set failed-flag
diff --git a/netwerk/test/unit/test_bug596443.js b/netwerk/test/unit/test_bug596443.js
--- a/netwerk/test/unit/test_bug596443.js
+++ b/netwerk/test/unit/test_bug596443.js
@@ -6,17 +6,19 @@ const Cr = Components.results;
 Cu.import("resource://testing-common/httpd.js");
 var httpserver = new HttpServer();
 
 var expectedOnStopRequests = 3;
 
 function setupChannel(suffix, xRequest, flags) {
     var ios = Components.classes["@mozilla.org/network/io-service;1"]
             .getService(Ci.nsIIOService);
-    var chan = ios.newChannel("http://localhost:4444" + suffix, "", null);
+    var chan = ios.newChannel("http://localhost:" +
+                              httpserver.identity.primaryPort +
+                              suffix, "", null);
     if (flags)
         chan.loadFlags |= flags;
 
     var httpChan = chan.QueryInterface(Components.interfaces.nsIHttpChannel);
     httpChan.setRequestHeader("x-request", xRequest, false);
         
     return httpChan;
 }
@@ -48,17 +50,17 @@ Listener.prototype = {
             do_timeout(10, function() {
                         httpserver.stop(do_test_finished);
                     });
     }
 };
 
 function run_test() {
     httpserver.registerPathHandler("/bug596443", handler);
-    httpserver.start(4444);
+    httpserver.start(-1);
 
     // make sure we have a profile so we can use the disk-cache
     do_get_profile();
 
     // clear cache
     evict_cache_entries();
 
     var ch0 = setupChannel("/bug596443", "Response0", Ci.nsIRequest.LOAD_BYPASS_CACHE);
diff --git a/netwerk/test/unit/test_bug618835.js b/netwerk/test/unit/test_bug618835.js
--- a/netwerk/test/unit/test_bug618835.js
+++ b/netwerk/test/unit/test_bug618835.js
@@ -29,45 +29,48 @@ function setupChannel(path) {
 
 // Verify that Content-Location-URI has been loaded once, load post_target
 function InitialListener() { }
 InitialListener.prototype = {
     onStartRequest: function(request, context) { },
     onStopRequest: function(request, context, status) {
         do_check_eq(1, numberOfCLHandlerCalls);
         do_execute_soon(function() {
-            var channel = setupChannel("http://localhost:4444/post");
+            var channel = setupChannel("http://localhost:" +
+                                       httpserv.identity.primaryPort + "/post");
             channel.requestMethod = "post";
             channel.asyncOpen(new RedirectingListener(), null);
         });
     }
 };
 
 // Verify that Location-URI has been loaded once, reload post_target
 function RedirectingListener() { }
 RedirectingListener.prototype = {
     onStartRequest: function(request, context) { },
     onStopRequest: function(request, context, status) {
         do_check_eq(1, numberOfHandlerCalls);
         do_execute_soon(function() {
-            var channel = setupChannel("http://localhost:4444/post");
+            var channel = setupChannel("http://localhost:" +
+                                       httpserv.identity.primaryPort + "/post");
             channel.requestMethod = "post";
             channel.asyncOpen(new VerifyingListener(), null);
         });
     }
 };
 
 // Verify that Location-URI has been loaded twice (cached entry invalidated),
 // reload Content-Location-URI
 function VerifyingListener() { }
 VerifyingListener.prototype = {
     onStartRequest: function(request, context) { },
     onStopRequest: function(request, context, status) {
         do_check_eq(2, numberOfHandlerCalls);
-        var channel = setupChannel("http://localhost:4444/cl");
+        var channel = setupChannel("http://localhost:" +
+                                   httpserv.identity.primaryPort + "/cl");
         channel.asyncOpen(new FinalListener(), null);
     }
 };
 
 // Verify that Location-URI has been loaded twice (cached entry invalidated),
 // stop test
 function FinalListener() { }
 FinalListener.prototype = {
@@ -78,23 +81,24 @@ FinalListener.prototype = {
     }
 };
 
 function run_test() {
   httpserv = new HttpServer();
   httpserv.registerPathHandler("/cl", content_location);
   httpserv.registerPathHandler("/post", post_target);
   httpserv.registerPathHandler("/redirect", redirect_target);
-  httpserv.start(4444);
+  httpserv.start(-1);
 
   // Clear cache
   evict_cache_entries();
 
   // Load Content-Location URI into cache and start the chain of loads
-  var channel = setupChannel("http://localhost:4444/cl");
+  var channel = setupChannel("http://localhost:" +
+                             httpserv.identity.primaryPort + "/cl");
   channel.asyncOpen(new InitialListener(), null);
 
   do_test_pending();
 }
 
 var numberOfCLHandlerCalls = 0;
 function content_location(metadata, response) {
     numberOfCLHandlerCalls++;
diff --git a/netwerk/test/unit/test_bug633743.js b/netwerk/test/unit/test_bug633743.js
--- a/netwerk/test/unit/test_bug633743.js
+++ b/netwerk/test/unit/test_bug633743.js
@@ -9,17 +9,19 @@ const VALUE_HDR_NAME = "X-HTTP-VALUE-HEA
 const VARY_HDR_NAME = "X-HTTP-VARY-HEADER";
 const CACHECTRL_HDR_NAME = "X-CACHE-CONTROL-HEADER";
 
 var httpserver = null;
 
 function make_channel(flags, vary, value) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
     getService(Ci.nsIIOService);
-  var chan = ios.newChannel("http://localhost:4444/bug633743", null, null);
+  var chan = ios.newChannel("http://localhost:" +
+                            httpserver.identity.primaryPort +
+                            "/bug633743", null, null);
   return chan.QueryInterface(Ci.nsIHttpChannel);
 }
 
 function Test(flags, varyHdr, sendValue, expectValue, cacheHdr) {
     this._flags = flags;
     this._varyHdr = varyHdr;
     this._sendVal = sendValue;
     this._expectVal = expectValue;
@@ -177,13 +179,13 @@ function handler(metadata, response) {
 
 function run_test() {
 
   // clear the cache
   evict_cache_entries();
 
   httpserver = new HttpServer();
   httpserver.registerPathHandler("/bug633743", handler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   run_next_test();
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_bug650995.js b/netwerk/test/unit/test_bug650995.js
--- a/netwerk/test/unit/test_bug650995.js
+++ b/netwerk/test/unit/test_bug650995.js
@@ -22,17 +22,19 @@ function repeatToLargerThan1K(data) {
     while(data.length <= 1024)
         data += data;
     return data;
 }
 
 function setupChannel(suffix, value) {
     var ios = Components.classes["@mozilla.org/network/io-service;1"]
             .getService(Ci.nsIIOService);
-    var chan = ios.newChannel("http://localhost:4444" + suffix, "", null);
+    var chan = ios.newChannel("http://localhost:" +
+                              httpserver.identity.primaryPort +
+                              suffix, "", null);
     var httpChan = chan.QueryInterface(Components.interfaces.nsIHttpChannel);
     httpChan.setRequestHeader("x-request", value, false);
     
     return httpChan;
 }
 
 var tests = [
              new InitializeCacheDevices(true, false), // enable and create mem-device
@@ -138,17 +140,17 @@ function TestCacheEntrySize(setSizeFunc,
         do_check_eq(secondExpectedReply, data);
         do_execute_soon(nextTest);
     }
 }
 
 function run_test()
 {
     httpserver.registerPathHandler("/bug650995", handler);
-    httpserver.start(4444);
+    httpserver.start(-1);
 
     prefService.setBoolPref("browser.cache.offline.enable", false);
 
     nextTest();
     do_test_pending();
 }
 
 function handler(metadata, response) {
diff --git a/netwerk/test/unit/test_bug659569.js b/netwerk/test/unit/test_bug659569.js
--- a/netwerk/test/unit/test_bug659569.js
+++ b/netwerk/test/unit/test_bug659569.js
@@ -7,34 +7,36 @@ Cu.import("resource://testing-common/htt
 Cu.import("resource://gre/modules/Services.jsm");
 var httpserver = new HttpServer();
 
 function setupChannel(suffix)
 {
     var ios =
         Components.classes["@mozilla.org/network/io-service;1"]
         .getService(Ci.nsIIOService);
-    var chan = ios.newChannel("http://localhost:4444" + suffix, "", null);
+    var chan = ios.newChannel("http://localhost:" +
+			      httpserver.identity.primaryPort +
+			      suffix, "", null);
     return chan;
 }
 
 function checkValueAndTrigger(request, data, ctx)
 {
     do_check_eq("Ok", data);
     httpserver.stop(do_test_finished);
 }
 
 function run_test()
 {
     // Allow all cookies.
     Services.prefs.setIntPref("network.cookie.cookieBehavior", 0);
 
     httpserver.registerPathHandler("/redirect1", redirectHandler1);
     httpserver.registerPathHandler("/redirect2", redirectHandler2);
-    httpserver.start(4444);
+    httpserver.start(-1);
 
     // clear cache
     evict_cache_entries();
 
     // load first time
     var channel = setupChannel("/redirect1");
     channel.asyncOpen(new ChannelListener(checkValueAndTrigger, null), null);
     do_test_pending();
diff --git a/netwerk/test/unit/test_bug667907.js b/netwerk/test/unit/test_bug667907.js
--- a/netwerk/test/unit/test_bug667907.js
+++ b/netwerk/test/unit/test_bug667907.js
@@ -4,18 +4,24 @@ const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpserver = null;
 var simplePath = "/simple";
 var normalPath = "/normal";
 var httpbody = "<html></html>";
-var uri1 = "http://localhost:4444" + simplePath;
-var uri2 = "http://localhost:4444" + normalPath;
+
+XPCOMUtils.defineLazyGetter(this, "uri1", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort + simplePath;
+});
+
+XPCOMUtils.defineLazyGetter(this, "uri2", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort + normalPath;
+});
 
 function make_channel(url) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 var listener_proto = {
@@ -49,17 +55,17 @@ function listener(contentType, terminati
 }
 listener.prototype = listener_proto;
 
 function run_test()
 {
   httpserver = new HttpServer();
   httpserver.registerPathHandler(simplePath, simpleHandler);
   httpserver.registerPathHandler(normalPath, normalHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   var channel = make_channel(uri1);
   channel.asyncOpen(new listener("text/plain", function() {
 	run_test2();
       }), null);
 
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_bug669001.js b/netwerk/test/unit/test_bug669001.js
--- a/netwerk/test/unit/test_bug669001.js
+++ b/netwerk/test/unit/test_bug669001.js
@@ -2,17 +2,20 @@ const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpServer = null;
 var path = "/bug699001";
-var URI = "http://localhost:4444" + path;
+
+XPCOMUtils.defineLazyGetter(this, "URI", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort + path;
+});
 
 function make_channel(url) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 var fetched;
@@ -88,17 +91,17 @@ function handler(metadata, response)
   response.setHeader("Vary", "User-Agent");
   response.setHeader("ETag", "1234");
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler(path, handler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   do_test_pending();
 
   nextTest();
 }
 
 function nextTest()
 {
diff --git a/netwerk/test/unit/test_bug770243.js b/netwerk/test/unit/test_bug770243.js
--- a/netwerk/test/unit/test_bug770243.js
+++ b/netwerk/test/unit/test_bug770243.js
@@ -15,30 +15,32 @@ const Cr = Components.results;
 Cu.import("resource://testing-common/httpd.js");
 
 var httpserv;
  
 function addCreds(scheme, host)
 {
   var authMgr = Components.classes['@mozilla.org/network/http-auth-manager;1']
                           .getService(Ci.nsIHttpAuthManager);
-  authMgr.setAuthIdentity(scheme, host, 4444, "basic", "secret", "/", "", "user", "pass");
+  authMgr.setAuthIdentity(scheme, host, httpserv.identity.primaryPort,
+                          "basic", "secret", "/", "", "user", "pass");
 }
 
 function clearCreds()
 {
   var authMgr = Components.classes['@mozilla.org/network/http-auth-manager;1']
                           .getService(Ci.nsIHttpAuthManager);
   authMgr.clearAll();
 }
 
 function makeChan() {
   var ios = Cc["@mozilla.org/network/io-service;1"]
                       .getService(Ci.nsIIOService);
-  var chan = ios.newChannel("http://localhost:4444/", null, null)
+  var chan = ios.newChannel("http://localhost:" +
+                            httpserv.identity.primaryPort + "/", null, null)
                 .QueryInterface(Ci.nsIHttpChannel);
   return chan;
 }
 
 // Array of handlers that are called one by one in response to expected requests
 
 var handlers = [
   // Test 1
@@ -192,20 +194,20 @@ var tests = [
 ];
 
 function run_test()
 {
   do_get_profile();
   
   httpserv = new HttpServer();
   httpserv.registerPathHandler("/", handler);
-  httpserv.start(4444);
+  httpserv.start(-1);
 
   const prefs = Cc["@mozilla.org/preferences-service;1"]
                          .getService(Ci.nsIPrefBranch);
   prefs.setCharPref("network.proxy.http", "localhost");
-  prefs.setIntPref("network.proxy.http_port", 4444);
+  prefs.setIntPref("network.proxy.http_port", httpserv.identity.primaryPort);
   prefs.setCharPref("network.proxy.no_proxies_on", "");
   prefs.setIntPref("network.proxy.type", 1);
 
   tests.shift()();
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_bug812167.js b/netwerk/test/unit/test_bug812167.js
--- a/netwerk/test/unit/test_bug812167.js
+++ b/netwerk/test/unit/test_bug812167.js
@@ -10,40 +10,49 @@ Cu.import("resource://testing-common/htt
 - check cache entry for the 302 response is cached only in memory device
 - get 302 with Expires: -1
 - check cache entry for the 302 response is not cached at all
 */
 
 var httpserver = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath1 = "/redirect-no-store/" + Math.random();
-var randomURI1 = "http://localhost:4444" + randomPath1;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI1", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort + randomPath1;
+});
+
 var randomPath2 = "/redirect-expires-past/" + Math.random();
-var randomURI2 = "http://localhost:4444" + randomPath2;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI2", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort + randomPath2;
+});
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 const responseBody = "response body";
 
 function redirectHandler_NoStore(metadata, response)
 {
   response.setStatusLine(metadata.httpVersion, 302, "Found");
-  response.setHeader("Location", "http://localhost:4444/content", false);
+  response.setHeader("Location", "http://localhost:" +
+                     httpserver.identity.primaryPort + "/content", false);
   response.setHeader("Cache-control", "no-store");
   return;
 }
 
 function redirectHandler_ExpiresInPast(metadata, response)
 {
   response.setStatusLine(metadata.httpVersion, 302, "Found");
-  response.setHeader("Location", "http://localhost:4444/content", false);
+  response.setHeader("Location", "http://localhost:" +
+                     httpserver.identity.primaryPort + "/content", false);
   response.setHeader("Expires", "-1");
   return;
 }
 
 function contentHandler(metadata, response)
 {
   response.setHeader("Content-Type", "text/plain");
   response.bodyOutputStream.write(responseBody, responseBody.length);
@@ -84,13 +93,13 @@ function finish_test()
 function run_test()
 {
   do_get_profile();
 
   httpserver = new HttpServer();
   httpserver.registerPathHandler(randomPath1, redirectHandler_NoStore);
   httpserver.registerPathHandler(randomPath2, redirectHandler_ExpiresInPast);
   httpserver.registerPathHandler("/content", contentHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   run_test_no_store();
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_cacheForOfflineUse_no-store.js b/netwerk/test/unit/test_cacheForOfflineUse_no-store.js
--- a/netwerk/test/unit/test_cacheForOfflineUse_no-store.js
+++ b/netwerk/test/unit/test_cacheForOfflineUse_no-store.js
@@ -7,17 +7,21 @@ const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpServer = null;
 const testFileName = "test_nsHttpChannel_CacheForOfflineUse-no-store";
 const cacheClientID = testFileName + "|fake-group-id";
 const basePath = "/" + testFileName + "/";
-const baseURI = "http://localhost:4444" + basePath;
+
+XPCOMUtils.defineLazyGetter(this, "baseURI", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort + basePath;
+});
+
 const normalEntry = "normal";
 const noStoreEntry = "no-store";
 
 var cacheUpdateObserver = null;
 
 function make_channel_for_offline_use(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
@@ -114,16 +118,16 @@ add_test(function test_noStore() {
 
 function run_test()
 {
   do_get_profile();
 
   httpServer = new HttpServer();
   httpServer.registerPathHandler(basePath + normalEntry, normalHandler);
   httpServer.registerPathHandler(basePath + noStoreEntry, noStoreHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
   run_next_test();
 }
 
 function finish_test(request, buffer)
 {
   httpServer.stop(do_test_finished);
 }
diff --git a/netwerk/test/unit/test_cache_jar.js b/netwerk/test/unit/test_cache_jar.js
--- a/netwerk/test/unit/test_cache_jar.js
+++ b/netwerk/test/unit/test_cache_jar.js
@@ -2,16 +2,20 @@ const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserv.identity.primaryPort + "/cached";
+});
+
 var httpserv = null;
 var handlers_called = 0;
 
 function cached_handler(metadata, response) {
   response.setHeader("Content-Type", "text/plain", false);
   response.setHeader("Cache-Control", "max-age=10000", false);
   response.setStatusLine(metadata.httpVersion, 200, "OK");
   var body = "0123456789";
@@ -37,17 +41,17 @@ function makeChan(url, appId, inBrowser)
 
 var firstTests = [[0, false, 1], [0, true, 1], [1, false, 1], [1, true, 1]];
 var secondTests = [[0, false, 0], [0, true, 0], [1, false, 0], [1, true, 1]];
 var thirdTests = [[0, false, 0], [0, true, 0], [1, false, 1], [1, true, 1]];
 
 function run_all_tests() {
   for (let test of firstTests) {
     handlers_called = 0;
-    var chan = makeChan("http://localhost:4444/cached", test[0], test[1]);
+    var chan = makeChan(URL, test[0], test[1]);
     chan.asyncOpen(new ChannelListener(doneFirstLoad, test[2]), null);
     yield;
   }
 
   // We can't easily cause webapp data to be cleared from the child process, so skip
   // the rest of these tests.
   let procType = Cc["@mozilla.org/xre/runtime;1"].getService(Ci.nsIXULRuntime).processType;
   if (procType != Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT)
@@ -57,50 +61,50 @@ function run_all_tests() {
     appId: 1,
     browserOnly: true,
     QueryInterface: XPCOMUtils.generateQI([Ci.mozIApplicationClearPrivateDataParams])
   };
   Services.obs.notifyObservers(subject, "webapps-clear-data", null);
 
   for (let test of secondTests) {
     handlers_called = 0;
-    var chan = makeChan("http://localhost:4444/cached", test[0], test[1]);
+    var chan = makeChan(URL, test[0], test[1]);
     chan.asyncOpen(new ChannelListener(doneFirstLoad, test[2]), null);
     yield;
   }
 
   subject = {
     appId: 1,
     browserOnly: false,
     QueryInterface: XPCOMUtils.generateQI([Ci.mozIApplicationClearPrivateDataParams])
   };
   Services.obs.notifyObservers(subject, "webapps-clear-data", null);
 
   for (let test of thirdTests) {
     handlers_called = 0;
-    var chan = makeChan("http://localhost:4444/cached", test[0], test[1]);
+    var chan = makeChan(URL, test[0], test[1]);
     chan.asyncOpen(new ChannelListener(doneFirstLoad, test[2]), null);
     yield;
   }
 }
 
 let gTests;
 function run_test() {
   do_get_profile();
   do_test_pending();
   httpserv = new HttpServer();
   httpserv.registerPathHandler("/cached", cached_handler);
-  httpserv.start(4444);
+  httpserv.start(-1);
   gTests = run_all_tests();
   gTests.next();
 }
 
 function doneFirstLoad(req, buffer, expected) {
   // Load it again, make sure it hits the cache
-  var chan = makeChan("http://localhost:4444/cached", 0, false);
+  var chan = makeChan(URL, 0, false);
   chan.asyncOpen(new ChannelListener(doneSecondLoad, expected), null);
 }
 
 function doneSecondLoad(req, buffer, expected) {
   do_check_eq(handlers_called, expected);
   try {
     gTests.next();
   } catch (x) {
diff --git a/netwerk/test/unit/test_cacheflags.js b/netwerk/test/unit/test_cacheflags.js
--- a/netwerk/test/unit/test_cacheflags.js
+++ b/netwerk/test/unit/test_cacheflags.js
@@ -1,20 +1,21 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
-var httpserver = null;
+var httpserver = new HttpServer();
+httpserver.start(-1);
 
 // Need to randomize, because apparently no one clears our cache
 var suffix = Math.random();
-var httpBase = "http://localhost:4444";
+var httpBase = "http://localhost:" + httpserver.identity.primaryPort;
 var httpsBase = "http://localhost:4445";
 var shortexpPath = "/shortexp" + suffix;
 var longexpPath = "/longexp/" + suffix;
 var longexp2Path = "/longexp/2/" + suffix;
 var nocachePath = "/nocache" + suffix;
 var nostorePath = "/nostore" + suffix;
 
 // We attach this to channel when we want to test Private Browsing mode
@@ -307,19 +308,17 @@ function longexp_handler(metadata, respo
 
 // test spaces around max-age value token
 function longexp2_handler(metadata, response) {
   response.setHeader("Cache-Control", "max-age = 10000", false);
   handler(metadata, response);
 }
 
 function run_test() {
-  httpserver = new HttpServer();
   httpserver.registerPathHandler(shortexpPath, shortexp_handler);
   httpserver.registerPathHandler(longexpPath, longexp_handler);
   httpserver.registerPathHandler(longexp2Path, longexp2_handler);
   httpserver.registerPathHandler(nocachePath, nocache_handler);
   httpserver.registerPathHandler(nostorePath, nostore_handler);
-  httpserver.start(4444);
 
   run_next_test();
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_channel_close.js b/netwerk/test/unit/test_channel_close.js
--- a/netwerk/test/unit/test_channel_close.js
+++ b/netwerk/test/unit/test_channel_close.js
@@ -1,24 +1,28 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort;
+});
+
 var httpserver = new HttpServer();
 var testpath = "/simple";
 var httpbody = "0123456789";
 
 var live_channels = [];
 
 function run_test() {
   httpserver.registerPathHandler(testpath, serverHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   var local_channel;
 
   // Opened channel that has no remaining references on shutdown
   local_channel = setupChannel(testpath);
   local_channel.asyncOpen(
       new ChannelListener(checkRequest, local_channel), null);
 
@@ -34,17 +38,17 @@ function run_test() {
   live_channels[1].asyncOpen(
       new ChannelListener(checkRequestFinish, live_channels[1]), null);
 
   do_test_pending();
 }
 
 function setupChannel(path) {
   var ios = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
-  var chan = ios.newChannel("http://localhost:4444" + path, "", null);
+  var chan = ios.newChannel(URL + path, "", null);
   chan.QueryInterface(Ci.nsIHttpChannel);
   chan.requestMethod = "GET";
   return chan;
 }
 
 function serverHandler(metadata, response) {
   response.setHeader("Content-Type", "text/plain", false);
   response.bodyOutputStream.write(httpbody, httpbody.length);
diff --git a/netwerk/test/unit/test_content_encoding_gzip.js b/netwerk/test/unit/test_content_encoding_gzip.js
--- a/netwerk/test/unit/test_content_encoding_gzip.js
+++ b/netwerk/test/unit/test_content_encoding_gzip.js
@@ -28,17 +28,18 @@ var tests = [
 	 0x00, 0x6e, 0x90, 0x7a, 0x85, 0x24, 0x00, 0x00, 0x00],
      datalen: 14 // the data length of the uncompressed document
     },
 ];
 
 function setupChannel(url) {
     var ios = Components.classes["@mozilla.org/network/io-service;1"].
                          getService(Ci.nsIIOService);
-    var chan = ios.newChannel("http://localhost:4444" + url, "", null);
+    var chan = ios.newChannel("http://localhost:" +
+			      httpserver.identity.primaryPort + url, "", null);
     return chan;
 }
 
 function startIter() {
     var channel = setupChannel(tests[index].url);
     channel.asyncOpen(new ChannelListener(completeIter, channel, tests[index].flags), null);
 }
 
@@ -49,17 +50,17 @@ function completeIter(request, data, ctx
     } else {
         httpserver.stop(do_test_finished);
     }
 }
 
 function run_test() {
     httpserver.registerPathHandler("/test/cegzip1", handler);
     httpserver.registerPathHandler("/test/cegzip2", handler);
-    httpserver.start(4444);
+    httpserver.start(-1);
 
     startIter();
     do_test_pending();
 }
 
 function handler(metadata, response) {
     response.setStatusLine(metadata.httpVersion, 200, "OK");
     response.setHeader("Content-Type", "text/plain", false);
diff --git a/netwerk/test/unit/test_content_sniffer.js b/netwerk/test/unit/test_content_sniffer.js
--- a/netwerk/test/unit/test_content_sniffer.js
+++ b/netwerk/test/unit/test_content_sniffer.js
@@ -79,31 +79,32 @@ function makeChan(url) {
                       .getService(Components.interfaces.nsIIOService);
   var chan = ios.newChannel(url, null, null);
   if (sniffing_enabled)
     chan.loadFlags |= Components.interfaces.nsIChannel.LOAD_CALL_CONTENT_SNIFFERS;
 
   return chan;
 }
 
-var urls = [
+var httpserv = null;
+var urls = null;
+
+function run_test() {
+  httpserv = new HttpServer();
+  httpserv.start(-1);
+
+  urls = [
   // NOTE: First URL here runs without our content sniffer
   "data:" + unknownType + ", Some text",
   "data:" + unknownType + ", Text", // Make sure sniffing works even if we
                                     // used the unknown content sniffer too
   "data:text/plain, Some more text",
-  "http://localhost:4444"
+    "http://localhost:" + httpserv.identity.primaryPort
 ];
 
-var httpserv = null;
-
-function run_test() {
-  httpserv = new HttpServer();
-  httpserv.start(4444);
-
   Components.manager.nsIComponentRegistrar.registerFactory(snifferCID,
     "Unit test content sniffer", snifferContract, sniffer);
 
   run_test_iteration(1);
 }
 
 function run_test_iteration(index) {
   if (index > urls.length) {
diff --git a/netwerk/test/unit/test_cookie_header.js b/netwerk/test/unit/test_cookie_header.js
--- a/netwerk/test/unit/test_cookie_header.js
+++ b/netwerk/test/unit/test_cookie_header.js
@@ -3,16 +3,20 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 Cu.import("resource://gre/modules/Services.jsm");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserv.identity.primaryPort + "/";
+});
+
 function inChildProcess() {
   return Cc["@mozilla.org/xre/app-info;1"]
            .getService(Ci.nsIXULRuntime)
            .processType != Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT;  
 }
 
 function check_request_header(chan, name, value) {
   var chanValue;
@@ -54,31 +58,31 @@ var listener = {
   },
 
   _iteration: 1
 };
 
 function makeChan() {
   var ios = Components.classes["@mozilla.org/network/io-service;1"]
                       .getService(Components.interfaces.nsIIOService);
-  var chan = ios.newChannel("http://localhost:4444/", null, null)
+  var chan = ios.newChannel(URL, null, null)
                 .QueryInterface(Components.interfaces.nsIHttpChannel);
 
   return chan;
 }
 
 var httpserv = null;
 
 function run_test() {
   // Allow all cookies if the pref service is available in this process.
   if (!inChildProcess())
     Services.prefs.setIntPref("network.cookie.cookieBehavior", 0);
 
   httpserv = new HttpServer();
-  httpserv.start(4444);
+  httpserv.start(-1);
 
   var chan = makeChan();
 
   chan.setRequestHeader("Cookie", cookieVal, false);
 
   chan.asyncOpen(listener, null);
 
   do_test_pending();
diff --git a/netwerk/test/unit/test_cookiejars.js b/netwerk/test/unit/test_cookiejars.js
--- a/netwerk/test/unit/test_cookiejars.js
+++ b/netwerk/test/unit/test_cookiejars.js
@@ -8,16 +8,20 @@
  *  are stored in separate namespaces ("cookie jars")
  */ 
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort;
+});
+
 Cu.import("resource://testing-common/httpd.js");
 Cu.import("resource://gre/modules/Services.jsm");
 var httpserver = new HttpServer();
 
 var cookieSetPath = "/setcookie";
 var cookieCheckPath = "/checkcookie";
 
 function inChildProcess() {
@@ -45,17 +49,17 @@ var tests = [
 ];
 
 // test number: index into 'tests' array
 var i = 0;
 
 function setupChannel(path)
 {
   var ios = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
-  var chan = ios.newChannel("http://localhost:4444" + path, "", null);
+  var chan = ios.newChannel(URL + path, "", null);
   chan.notificationCallbacks = tests[i].loadContext;
   chan.QueryInterface(Ci.nsIHttpChannel);
   return chan;
 }
 
 function setCookie() {
   var channel = setupChannel(cookieSetPath);
   channel.setRequestHeader("foo-set-cookie", tests[i].cookieName, false);
@@ -117,17 +121,17 @@ function completeCheckCookie(request, da
 function run_test()
 {
   // Allow all cookies if the pref service is available in this process.
   if (!inChildProcess())
     Services.prefs.setIntPref("network.cookie.cookieBehavior", 0);
 
   httpserver.registerPathHandler(cookieSetPath, cookieSetHandler);
   httpserver.registerPathHandler(cookieCheckPath, cookieCheckHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   setCookie();
   do_test_pending();
 }
 
 function cookieSetHandler(metadata, response)
 {
   var cookieName = metadata.getHeader("foo-set-cookie");
diff --git a/netwerk/test/unit/test_duplicate_headers.js b/netwerk/test/unit/test_duplicate_headers.js
--- a/netwerk/test/unit/test_duplicate_headers.js
+++ b/netwerk/test/unit/test_duplicate_headers.js
@@ -8,24 +8,28 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort;
+});
+
 var httpserver = new HttpServer();
 var index = 0;
 var test_flags = new Array();
 var testPathBase = "/dupe_hdrs";
 
 function run_test()
 {
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   do_test_pending();
   run_test_number(1);
 }
 
 function run_test_number(num)
 {
   testPath = testPathBase + num;
@@ -36,17 +40,17 @@ function run_test_number(num)
   channel.asyncOpen(new ChannelListener(eval("completeTest" + num),
                                         channel, flags), null);
 }
 
 function setupChannel(url)
 {
   var ios = Components.classes["@mozilla.org/network/io-service;1"].
                        getService(Ci.nsIIOService);
-  var chan = ios.newChannel("http://localhost:4444" + url, "", null);
+  var chan = ios.newChannel(URL + url, "", null);
   var httpChan = chan.QueryInterface(Components.interfaces.nsIHttpChannel);
   return httpChan;
 }
 
 function endTests()
 {
   httpserver.stop(do_test_finished);
 }
@@ -192,17 +196,17 @@ test_flags[6] = CL_EXPECT_FAILURE;
 
 function handler6(metadata, response)
 {
   var body = "012345678901234567890123456789";
   response.seizePower();
   response.write("HTTP/1.0 301 Moved\r\n");
   response.write("Content-Type: text/plain\r\n");
   response.write("Content-Length: 30\r\n");
-  response.write("Location: http://localhost:4444/content\r\n");
+  response.write("Location: " + URL + "/content\r\n");
   response.write("Location: http://www.microsoft.com/\r\n");
   response.write("Connection: close\r\n");
   response.write("\r\n");
   response.write(body);
   response.finish();
 }
 
 function completeTest6(request, data, ctx)
@@ -219,18 +223,18 @@ function completeTest6(request, data, ct
 function handler7(metadata, response)
 {
   var body = "012345678901234567890123456789";
   response.seizePower();
   response.write("HTTP/1.0 301 Moved\r\n");
   response.write("Content-Type: text/plain\r\n");
   response.write("Content-Length: 30\r\n");
   // redirect to previous test handler that completes OK: test 5
-  response.write("Location: http://localhost:4444" + testPathBase + "5\r\n");
-  response.write("Location: http://localhost:4444" + testPathBase + "5\r\n");
+  response.write("Location: " + URL + testPathBase + "5\r\n");
+  response.write("Location: " + URL + testPathBase + "5\r\n");
   response.write("Connection: close\r\n");
   response.write("\r\n");
   response.write(body);
   response.finish();
 }
 
 function completeTest7(request, data, ctx)
 {
@@ -254,17 +258,17 @@ test_flags[8] = CL_EXPECT_FAILURE;
 function handler8(metadata, response)
 {
   var body = "012345678901234567890123456789";
   response.seizePower();
   response.write("HTTP/1.0 301 Moved\r\n");
   response.write("Content-Type: text/plain\r\n");
   response.write("Content-Length: 30\r\n");
   // redirect to previous test handler that completes OK: test 4
-  response.write("Location: http://localhost:4444" + testPathBase + "4\r\n");
+  response.write("Location: " + URL + testPathBase + "4\r\n");
   response.write("Location:\r\n");
   response.write("Connection: close\r\n");
   response.write("\r\n");
   response.write(body);
   response.finish();
 }
 
 function completeTest8(request, data, ctx)
@@ -282,20 +286,20 @@ test_flags[9] = CL_EXPECT_FAILURE;
 function handler9(metadata, response)
 {
   var body = "012345678901234567890123456789";
   response.seizePower();
   response.write("HTTP/1.0 301 Moved\r\n");
   response.write("Content-Type: text/plain\r\n");
   response.write("Content-Length: 30\r\n");
   // redirect to previous test handler that completes OK: test 2 
-  response.write("Location: http://localhost:4444" + testPathBase + "2\r\n");
+  response.write("Location: " + URL + testPathBase + "2\r\n");
   response.write("Location:\r\n");
   // redirect to previous test handler that completes OK: test 4
-  response.write("Location: http://localhost:4444" + testPathBase + "4\r\n");
+  response.write("Location: " + URL + testPathBase + "4\r\n");
   response.write("Connection: close\r\n");
   response.write("\r\n");
   response.write(body);
   response.finish();
 }
 
 function completeTest9(request, data, ctx)
 {
@@ -583,17 +587,17 @@ function handler20(metadata, response)
 {
   var body = "012345678901234567890123456789";
   response.seizePower();
   response.write("HTTP/1.0 301 Moved\r\n");
   response.write("Content-Type: text/plain\r\n");
   response.write("Content-Length: 30\r\n");
   // redirect to previous test handler that completes OK: test 4
   response.write("Location:\r\n");
-  response.write("Location: http://localhost:4444" + testPathBase + "4\r\n");
+  response.write("Location: " + URL + testPathBase + "4\r\n");
   response.write("Connection: close\r\n");
   response.write("\r\n");
   response.write(body);
   response.finish();
 }
 
 function completeTest20(request, data, ctx)
 {
diff --git a/netwerk/test/unit/test_event_sink.js b/netwerk/test/unit/test_event_sink.js
--- a/netwerk/test/unit/test_event_sink.js
+++ b/netwerk/test/unit/test_event_sink.js
@@ -2,16 +2,20 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserv.identity.primaryPort;
+});
+
 const sinkCID = Components.ID("{14aa4b81-e266-45cb-88f8-89595dece114}");
 const sinkContract = "@mozilla.org/network/unittest/channeleventsink;1";
 
 const categoryName = "net-channel-event-sinks";
 
 /**
  * This object is both a factory and an nsIChannelEventSink implementation (so, it
  * is de-facto a service). It's also an interface requestor that gives out
@@ -106,23 +110,23 @@ function makeChan(url) {
 }
 
 var httpserv = null;
 
 function run_test() {
   httpserv = new HttpServer();
   httpserv.registerPathHandler("/redirect", redirect);
   httpserv.registerPathHandler("/redirectfile", redirectfile);
-  httpserv.start(4444);
+  httpserv.start(-1);
 
   Components.manager.nsIComponentRegistrar.registerFactory(sinkCID,
     "Unit test Event sink", sinkContract, eventsink);
 
   // Step 1: Set the callbacks on the listener itself
-  var chan = makeChan("http://localhost:4444/redirect");
+  var chan = makeChan(URL + "/redirect");
   chan.notificationCallbacks = eventsink;
 
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 function run_test_continued() {
@@ -131,23 +135,23 @@ function run_test_continued() {
   var catMan = Components.classes["@mozilla.org/categorymanager;1"]
                          .getService(Components.interfaces.nsICategoryManager);
 
   var chan;
   if (listener._iteration == 1) {
     // Step 2: Category entry
     catMan.nsICategoryManager.addCategoryEntry(categoryName, "unit test",
                                                sinkContract, false, true);
-    chan = makeChan("http://localhost:4444/redirect")
+    chan = makeChan(URL + "/redirect")
   } else {
     // Step 3: Global contract id
     catMan.nsICategoryManager.deleteCategoryEntry(categoryName, "unit test",
                                                   false);
     listener.expectSinkCall = false;
-    chan = makeChan("http://localhost:4444/redirectfile");
+    chan = makeChan(URL + "/redirectfile");
   }
 
   listener._iteration++;
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
diff --git a/netwerk/test/unit/test_fallback_no-cache-entry_canceled.js b/netwerk/test/unit/test_fallback_no-cache-entry_canceled.js
--- a/netwerk/test/unit/test_fallback_no-cache-entry_canceled.js
+++ b/netwerk/test/unit/test_fallback_no-cache-entry_canceled.js
@@ -3,17 +3,20 @@ const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpServer = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/redirect/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort + randomPath;
+});
 
 var cacheUpdateObserver = null;
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
@@ -57,21 +60,21 @@ function finish_test(request, buffer)
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/masterEntry", masterEntryHandler);
   httpServer.registerPathHandler("/manifest", manifestHandler);
   httpServer.registerPathHandler("/content", contentHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var pm = Cc["@mozilla.org/permissionmanager;1"]
     .getService(Ci.nsIPermissionManager);
-  var uri = make_uri("http://localhost:4444");
+  var uri = make_uri("http://localhost:" + httpServer.identity.primaryPort);
   var principal = Components.classes["@mozilla.org/scriptsecuritymanager;1"]
                     .getService(Ci.nsIScriptSecurityManager)
                     .getNoAppCodebasePrincipal(uri);
 
   if (pm.testPermissionFromPrincipal(principal, "offline-app") != 0) {
     dump("Previous test failed to clear offline-app permission!  Expect failures.\n");
   }
   pm.addFromPrincipal(principal, "offline-app", Ci.nsIPermissionManager.ALLOW_ACTION);
@@ -97,14 +100,16 @@ function run_test()
   }}
 
   var os = Cc["@mozilla.org/observer-service;1"].
            getService(Ci.nsIObserverService);
   os.addObserver(cacheUpdateObserver, "offline-cache-update-completed", false);
 
   var us = Cc["@mozilla.org/offlinecacheupdate-service;1"].
            getService(Ci.nsIOfflineCacheUpdateService);
-  us.scheduleUpdate(make_uri("http://localhost:4444/manifest"),
-                    make_uri("http://localhost:4444/masterEntry"),
+  us.scheduleUpdate(make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/manifest"),
+                    make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/masterEntry"),
                     null);
 
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_fallback_no-cache-entry_passing.js b/netwerk/test/unit/test_fallback_no-cache-entry_passing.js
--- a/netwerk/test/unit/test_fallback_no-cache-entry_passing.js
+++ b/netwerk/test/unit/test_fallback_no-cache-entry_passing.js
@@ -3,17 +3,20 @@ const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpServer = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/redirect/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort + randomPath;
+});
 
 var cacheUpdateObserver = null;
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
@@ -57,21 +60,21 @@ function finish_test(request, buffer)
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/masterEntry", masterEntryHandler);
   httpServer.registerPathHandler("/manifest", manifestHandler);
   httpServer.registerPathHandler("/content", contentHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var pm = Cc["@mozilla.org/permissionmanager;1"]
     .getService(Ci.nsIPermissionManager);
-  var uri = make_uri("http://localhost:4444");
+  var uri = make_uri("http://localhost:" + httpServer.identity.primaryPort);
   var principal = Components.classes["@mozilla.org/scriptsecuritymanager;1"]
                     .getService(Ci.nsIScriptSecurityManager)
                     .getNoAppCodebasePrincipal(uri);
 
   if (pm.testPermissionFromPrincipal(principal, "offline-app") != 0) {
     dump("Previous test failed to clear offline-app permission!  Expect failures.\n");
   }
   pm.addFromPrincipal(principal, "offline-app", Ci.nsIPermissionManager.ALLOW_ACTION);
@@ -96,14 +99,16 @@ function run_test()
   }}
 
   var os = Cc["@mozilla.org/observer-service;1"].
            getService(Ci.nsIObserverService);
   os.addObserver(cacheUpdateObserver, "offline-cache-update-completed", false);
 
   var us = Cc["@mozilla.org/offlinecacheupdate-service;1"].
            getService(Ci.nsIOfflineCacheUpdateService);
-  us.scheduleUpdate(make_uri("http://localhost:4444/manifest"),
-                    make_uri("http://localhost:4444/masterEntry"),
+  us.scheduleUpdate(make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/manifest"),
+                    make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/masterEntry"),
                     null);
 
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_fallback_redirect-to-different-origin_canceled.js b/netwerk/test/unit/test_fallback_redirect-to-different-origin_canceled.js
--- a/netwerk/test/unit/test_fallback_redirect-to-different-origin_canceled.js
+++ b/netwerk/test/unit/test_fallback_redirect-to-different-origin_canceled.js
@@ -3,17 +3,20 @@ const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpServer = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/redirect/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort + randomPath;
+});
 
 var cacheUpdateObserver = null;
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
@@ -65,21 +68,21 @@ function finish_test(request, buffer)
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/masterEntry", masterEntryHandler);
   httpServer.registerPathHandler("/manifest", manifestHandler);
   httpServer.registerPathHandler("/content", contentHandler);
   httpServer.registerPathHandler(randomPath, redirectHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var pm = Cc["@mozilla.org/permissionmanager;1"]
     .getService(Ci.nsIPermissionManager);
-  var uri = make_uri("http://localhost:4444");
+  var uri = make_uri("http://localhost:" + httpServer.identity.primaryPort);
   var principal = Cc["@mozilla.org/scriptsecuritymanager;1"]
                     .getService(Ci.nsIScriptSecurityManager)
                     .getNoAppCodebasePrincipal(uri);
 
   if (pm.testPermissionFromPrincipal(principal, "offline-app") != 0) {
     dump("Previous test failed to clear offline-app permission!  Expect failures.\n");
   }
   pm.addFromPrincipal(principal, "offline-app", Ci.nsIPermissionManager.ALLOW_ACTION);
@@ -101,14 +104,16 @@ function run_test()
   }}
 
   var os = Cc["@mozilla.org/observer-service;1"].
            getService(Ci.nsIObserverService);
   os.addObserver(cacheUpdateObserver, "offline-cache-update-completed", false);
 
   var us = Cc["@mozilla.org/offlinecacheupdate-service;1"].
            getService(Ci.nsIOfflineCacheUpdateService);
-  us.scheduleUpdate(make_uri("http://localhost:4444/manifest"),
-                    make_uri("http://localhost:4444/masterEntry"),
+  us.scheduleUpdate(make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/manifest"),
+                    make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/masterEntry"),
                     null);
 
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_fallback_redirect-to-different-origin_passing.js b/netwerk/test/unit/test_fallback_redirect-to-different-origin_passing.js
--- a/netwerk/test/unit/test_fallback_redirect-to-different-origin_passing.js
+++ b/netwerk/test/unit/test_fallback_redirect-to-different-origin_passing.js
@@ -3,17 +3,20 @@ const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpServer = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/redirect/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort + randomPath;
+});
 
 var cacheUpdateObserver = null;
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
@@ -65,21 +68,21 @@ function finish_test(request, buffer)
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/masterEntry", masterEntryHandler);
   httpServer.registerPathHandler("/manifest", manifestHandler);
   httpServer.registerPathHandler("/content", contentHandler);
   httpServer.registerPathHandler(randomPath, redirectHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var pm = Cc["@mozilla.org/permissionmanager;1"]
     .getService(Ci.nsIPermissionManager);
-  var uri = make_uri("http://localhost:4444");
+  var uri = make_uri("http://localhost:" + httpServer.identity.primaryPort);
   var principal = Cc["@mozilla.org/scriptsecuritymanager;1"]
                     .getService(Ci.nsIScriptSecurityManager)
                     .getNoAppCodebasePrincipal(uri);
 
   if (pm.testPermissionFromPrincipal(principal, "offline-app") != 0) {
     dump("Previous test failed to clear offline-app permission!  Expect failures.\n");
   }
   pm.addFromPrincipal(principal, "offline-app", Ci.nsIPermissionManager.ALLOW_ACTION);
@@ -100,14 +103,16 @@ function run_test()
   }}
 
   var os = Cc["@mozilla.org/observer-service;1"].
            getService(Ci.nsIObserverService);
   os.addObserver(cacheUpdateObserver, "offline-cache-update-completed", false);
 
   var us = Cc["@mozilla.org/offlinecacheupdate-service;1"].
            getService(Ci.nsIOfflineCacheUpdateService);
-  us.scheduleUpdate(make_uri("http://localhost:4444/manifest"),
-                    make_uri("http://localhost:4444/masterEntry"),
+  us.scheduleUpdate(make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/manifest"),
+                    make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/masterEntry"),
                     null);
 
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_fallback_request-error_canceled.js b/netwerk/test/unit/test_fallback_request-error_canceled.js
--- a/netwerk/test/unit/test_fallback_request-error_canceled.js
+++ b/netwerk/test/unit/test_fallback_request-error_canceled.js
@@ -3,17 +3,20 @@ const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpServer = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/redirect/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort + randomPath;
+});
 
 var cacheUpdateObserver = null;
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
@@ -64,21 +67,21 @@ function finish_test(request, buffer)
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/masterEntry", masterEntryHandler);
   httpServer.registerPathHandler("/manifest", manifestHandler);
   httpServer.registerPathHandler("/content", contentHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var pm = Cc["@mozilla.org/permissionmanager;1"]
     .getService(Ci.nsIPermissionManager);
-  var uri = make_uri("http://localhost:4444");
+  var uri = make_uri("http://localhost:" + httpServer.identity.primaryPort);
   var principal = Cc["@mozilla.org/scriptsecuritymanager;1"]
                     .getService(Ci.nsIScriptSecurityManager)
                     .getNoAppCodebasePrincipal(uri);
 
   if (pm.testPermissionFromPrincipal(principal, "offline-app") != 0) {
     dump("Previous test failed to clear offline-app permission!  Expect failures.\n");
   }
   pm.addFromPrincipal(principal, "offline-app", Ci.nsIPermissionManager.ALLOW_ACTION);
@@ -87,16 +90,19 @@ function run_test()
     .getService(Ci.nsIPrefBranch);
   dump(ps.getBoolPref("browser.cache.offline.enable"));
   ps.setBoolPref("browser.cache.offline.enable", true);
   ps.setComplexValue("browser.cache.offline.parent_directory", Ci.nsILocalFile, do_get_profile());
 
   cacheUpdateObserver = {observe: function() {
     dump("got offline-cache-update-completed\n");
     // offline cache update completed.
+
+    // doing this to eval the lazy getter, otherwise the make_channel call would hang
+    randomURI;
     httpServer.stop(function() {
       // Now shut the server down to have an error in onStartRequest
       var chan = make_channel(randomURI);
       chan.notificationCallbacks = new ChannelEventSink(ES_ABORT_REDIRECT);
       var chanac = chan.QueryInterface(Ci.nsIApplicationCacheChannel);
       chanac.chooseApplicationCache = true;
       chan.asyncOpen(new ChannelListener(finish_test, null, CL_EXPECT_FAILURE), null);
     });
@@ -104,14 +110,16 @@ function run_test()
 
 
   var os = Cc["@mozilla.org/observer-service;1"].
            getService(Ci.nsIObserverService);
   os.addObserver(cacheUpdateObserver, "offline-cache-update-completed", false);
 
   var us = Cc["@mozilla.org/offlinecacheupdate-service;1"].
            getService(Ci.nsIOfflineCacheUpdateService);
-  us.scheduleUpdate(make_uri("http://localhost:4444/manifest"),
-                    make_uri("http://localhost:4444/masterEntry"),
+  us.scheduleUpdate(make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/manifest"),
+                    make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/masterEntry"),
                     null);
 
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_fallback_request-error_passing.js b/netwerk/test/unit/test_fallback_request-error_passing.js
--- a/netwerk/test/unit/test_fallback_request-error_passing.js
+++ b/netwerk/test/unit/test_fallback_request-error_passing.js
@@ -3,17 +3,20 @@ const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpServer = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/redirect/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort + randomPath;
+});
 
 var cacheUpdateObserver = null;
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
@@ -64,21 +67,21 @@ function finish_test(request, buffer)
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/masterEntry", masterEntryHandler);
   httpServer.registerPathHandler("/manifest", manifestHandler);
   httpServer.registerPathHandler("/content", contentHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var pm = Cc["@mozilla.org/permissionmanager;1"]
     .getService(Ci.nsIPermissionManager);
-  var uri = make_uri("http://localhost:4444");
+  var uri = make_uri("http://localhost:" + httpServer.identity.primaryPort);
   var principal = Cc["@mozilla.org/scriptsecuritymanager;1"]
                     .getService(Ci.nsIScriptSecurityManager)
                     .getNoAppCodebasePrincipal(uri);
 
   if (pm.testPermissionFromPrincipal(principal, "offline-app") != 0) {
     dump("Previous test failed to clear offline-app permission!  Expect failures.\n");
   }
   pm.addFromPrincipal(principal, "offline-app", Ci.nsIPermissionManager.ALLOW_ACTION);
@@ -87,30 +90,33 @@ function run_test()
     .getService(Ci.nsIPrefBranch);
   dump(ps.getBoolPref("browser.cache.offline.enable"));
   ps.setBoolPref("browser.cache.offline.enable", true);
   ps.setComplexValue("browser.cache.offline.parent_directory", Ci.nsILocalFile, do_get_profile());
 
   cacheUpdateObserver = {observe: function() {
     dump("got offline-cache-update-completed\n");
     // offline cache update completed.
+    var _x = randomURI; // doing this so the lazy value gets computed
     httpServer.stop(function() {
       // Now shut the server down to have an error in onstartrequest
       var chan = make_channel(randomURI);
       var chanac = chan.QueryInterface(Ci.nsIApplicationCacheChannel);
       chanac.chooseApplicationCache = true;
       chan.asyncOpen(new ChannelListener(finish_test), null);
     });
   }}
 
 
   var os = Cc["@mozilla.org/observer-service;1"].
            getService(Ci.nsIObserverService);
   os.addObserver(cacheUpdateObserver, "offline-cache-update-completed", false);
 
   var us = Cc["@mozilla.org/offlinecacheupdate-service;1"].
            getService(Ci.nsIOfflineCacheUpdateService);
-  us.scheduleUpdate(make_uri("http://localhost:4444/manifest"),
-                    make_uri("http://localhost:4444/masterEntry"),
+  us.scheduleUpdate(make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/manifest"),
+                    make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/masterEntry"),
                     null);
 
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_fallback_response-error_canceled.js b/netwerk/test/unit/test_fallback_response-error_canceled.js
--- a/netwerk/test/unit/test_fallback_response-error_canceled.js
+++ b/netwerk/test/unit/test_fallback_response-error_canceled.js
@@ -3,17 +3,20 @@ const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpServer = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/error/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort + randomPath;
+});
 
 var cacheUpdateObserver = null;
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
@@ -64,21 +67,21 @@ function finish_test(request, buffer)
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/masterEntry", masterEntryHandler);
   httpServer.registerPathHandler("/manifest", manifestHandler);
   httpServer.registerPathHandler("/content", contentHandler);
   httpServer.registerPathHandler(randomPath, errorHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var pm = Cc["@mozilla.org/permissionmanager;1"]
     .getService(Ci.nsIPermissionManager);
-  var uri = make_uri("http://localhost:4444");
+  var uri = make_uri("http://localhost:" + httpServer.identity.primaryPort);
   var principal = Cc["@mozilla.org/scriptsecuritymanager;1"]
                     .getService(Ci.nsIScriptSecurityManager)
                     .getNoAppCodebasePrincipal(uri);
 
   if (pm.testPermissionFromPrincipal(principal, "offline-app") != 0) {
     dump("Previous test failed to clear offline-app permission!  Expect failures.\n");
   }
   pm.addFromPrincipal(principal, "offline-app", Ci.nsIPermissionManager.ALLOW_ACTION);
@@ -100,14 +103,16 @@ function run_test()
   }}
 
   var os = Cc["@mozilla.org/observer-service;1"].
            getService(Ci.nsIObserverService);
   os.addObserver(cacheUpdateObserver, "offline-cache-update-completed", false);
 
   var us = Cc["@mozilla.org/offlinecacheupdate-service;1"].
            getService(Ci.nsIOfflineCacheUpdateService);
-  us.scheduleUpdate(make_uri("http://localhost:4444/manifest"),
-                    make_uri("http://localhost:4444/masterEntry"),
+  us.scheduleUpdate(make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/manifest"),
+                    make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/masterEntry"),
                     null);
 
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_fallback_response-error_passing.js b/netwerk/test/unit/test_fallback_response-error_passing.js
--- a/netwerk/test/unit/test_fallback_response-error_passing.js
+++ b/netwerk/test/unit/test_fallback_response-error_passing.js
@@ -3,17 +3,20 @@ const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpServer = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/error/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort + randomPath;
+});
 
 var cacheUpdateObserver = null;
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
@@ -64,21 +67,21 @@ function finish_test(request, buffer)
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/masterEntry", masterEntryHandler);
   httpServer.registerPathHandler("/manifest", manifestHandler);
   httpServer.registerPathHandler("/content", contentHandler);
   httpServer.registerPathHandler(randomPath, errorHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var pm = Cc["@mozilla.org/permissionmanager;1"]
     .getService(Ci.nsIPermissionManager);
-  var uri = make_uri("http://localhost:4444");
+  var uri = make_uri("http://localhost:" + httpServer.identity.primaryPort);
   var principal = Cc["@mozilla.org/scriptsecuritymanager;1"]
                     .getService(Ci.nsIScriptSecurityManager)
                     .getNoAppCodebasePrincipal(uri);
 
   if (pm.testPermissionFromPrincipal(principal, "offline-app") != 0) {
     dump("Previous test failed to clear offline-app permission!  Expect failures.\n");
   }
   pm.addFromPrincipal(principal, "offline-app", Ci.nsIPermissionManager.ALLOW_ACTION);
@@ -99,14 +102,16 @@ function run_test()
   }}
 
   var os = Cc["@mozilla.org/observer-service;1"].
            getService(Ci.nsIObserverService);
   os.addObserver(cacheUpdateObserver, "offline-cache-update-completed", false);
 
   var us = Cc["@mozilla.org/offlinecacheupdate-service;1"].
            getService(Ci.nsIOfflineCacheUpdateService);
-  us.scheduleUpdate(make_uri("http://localhost:4444/manifest"),
-                    make_uri("http://localhost:4444/masterEntry"),
+  us.scheduleUpdate(make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/manifest"),
+                    make_uri("http://localhost:" +
+                             httpServer.identity.primaryPort + "/masterEntry"),
                     null);
 
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_force_sniffing.js b/netwerk/test/unit/test_force_sniffing.js
--- a/netwerk/test/unit/test_force_sniffing.js
+++ b/netwerk/test/unit/test_force_sniffing.js
@@ -62,24 +62,26 @@ function makeChan(url) {
   // Force sniffing if we have "application/octet-stream" as Content-Type
   chan.loadFlags |= Components.interfaces
                               .nsIChannel
                               .LOAD_TREAT_APPLICATION_OCTET_STREAM_AS_UNKNOWN;
 
   return chan;
 }
 
-var url = "http://localhost:4444/test";
+XPCOMUtils.defineLazyGetter(this, "url", function() {
+  return "http://localhost:" + httpserv.identity.primaryPort + "/test";
+});
 
 var httpserv = null;
 
 function run_test() {
   httpserv = new HttpServer();
   httpserv.registerPathHandler("/test", handler);
-  httpserv.start(4444);
+  httpserv.start(-1);
 
   // Register our fake sniffer that always returns the content-type we want.
   Components.manager.nsIComponentRegistrar.registerFactory(snifferCID,
                        "Unit test content sniffer", snifferContract, sniffer);
 
   var catMan = Components.classes["@mozilla.org/categorymanager;1"]
                          .getService(Components.interfaces.nsICategoryManager);
   catMan.nsICategoryManager.addCategoryEntry(categoryName, snifferContract,
diff --git a/netwerk/test/unit/test_gzipped_206.js b/netwerk/test/unit/test_gzipped_206.js
--- a/netwerk/test/unit/test_gzipped_206.js
+++ b/netwerk/test/unit/test_gzipped_206.js
@@ -56,33 +56,35 @@ function cachedHandler(metadata, respons
 
   response.processAsync();
   bos.writeByteArray(body, body.length);
   response.finish();
 }
 
 function continue_test(request, data) {
   do_check_true(17 == data.length);
-  var chan = make_channel("http://localhost:4444/cached/test.gz");
+  var chan = make_channel("http://localhost:" +
+                          httpserver.identity.primaryPort + "/cached/test.gz");
   chan.asyncOpen(new ChannelListener(finish_test, null, CL_EXPECT_GZIP), null);
 }
 
 function finish_test(request, data, ctx) {
   do_check_eq(request.status, 0);
   do_check_eq(data.length, responseBody.length);
   for (var i = 0; i < data.length; ++i) {
     do_check_eq(data.charCodeAt(i), responseBody[i]);
   }
   httpserver.stop(do_test_finished);
 }
 
 function run_test() {
   httpserver = new HttpServer();
   httpserver.registerPathHandler("/cached/test.gz", cachedHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   // wipe out cached content
   evict_cache_entries();
 
-  var chan = make_channel("http://localhost:4444/cached/test.gz");
+  var chan = make_channel("http://localhost:" +
+                          httpserver.identity.primaryPort + "/cached/test.gz");
   chan.asyncOpen(new ChannelListener(continue_test, null, CL_EXPECT_GZIP), null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_head.js b/netwerk/test/unit/test_head.js
--- a/netwerk/test/unit/test_head.js
+++ b/netwerk/test/unit/test_head.js
@@ -5,16 +5,20 @@
 // Note: sets Cc and Ci variables
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort;
+});
+
 var httpserver = new HttpServer();
 var testpath = "/simple";
 var httpbody = "0123456789";
 var channel;
 var ios;
 
 var dbg=0
 if (dbg) { print("============== START =========="); }
@@ -23,17 +27,17 @@ function run_test() {
   setup_test();
   do_test_pending();
 }
 
 function setup_test() {
   if (dbg) { print("============== setup_test: in"); }
 
   httpserver.registerPathHandler(testpath, serverHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   channel = setupChannel(testpath);
 
   channel.setRequestHeader("ReplaceMe", "initial value", true);
   var setOK = channel.getRequestHeader("ReplaceMe");
   do_check_eq(setOK, "initial value");
   channel.setRequestHeader("ReplaceMe", "replaced", false);
   setOK = channel.getRequestHeader("ReplaceMe");
@@ -59,17 +63,17 @@ function setup_test() {
   // ChannelListener defined in head_channels.js
   channel.asyncOpen(new ChannelListener(checkRequestResponse, channel), null);
 
   if (dbg) { print("============== setup_test: out"); }
 }
 
 function setupChannel(path) {
   ios = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
-  var chan = ios.newChannel("http://localhost:4444" + path, "", null);
+  var chan = ios.newChannel(URL + path, "", null);
   chan.QueryInterface(Ci.nsIHttpChannel);
   chan.requestMethod = "GET";
   return chan;
 }
 
 function serverHandler(metadata, response) {
   if (dbg) { print("============== serverHandler: in"); }
 
diff --git a/netwerk/test/unit/test_headers.js b/netwerk/test/unit/test_headers.js
--- a/netwerk/test/unit/test_headers.js
+++ b/netwerk/test/unit/test_headers.js
@@ -22,25 +22,29 @@ var lastTest = 4;    // set to test of i
 // Note: sets Cc and Ci variables
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort;
+});
+
 var httpserver = new HttpServer();
 var index = 0;
 var nextTest = firstTest;
 var test_flags = new Array();
 var testPathBase = "/test_headers";
 
 function run_test()
 {
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   do_test_pending();
   run_test_number(nextTest);
 }
 
 function runNextTest()
 {
   if (nextTest == lastTest) {
@@ -67,17 +71,17 @@ function run_test_number(num)
   channel.asyncOpen(new ChannelListener(eval("completeTest" + num),
                                         channel, flags), null);
 }
 
 function setupChannel(url)
 {
   var ios = Components.classes["@mozilla.org/network/io-service;1"].
                        getService(Ci.nsIIOService);
-  var chan = ios.newChannel("http://localhost:4444" + url, "", null);
+  var chan = ios.newChannel(URL + url, "", null);
   var httpChan = chan.QueryInterface(Components.interfaces.nsIHttpChannel);
   return httpChan;
 }
 
 function endTests()
 {
   httpserver.stop(do_test_finished);
 }
diff --git a/netwerk/test/unit/test_httpcancel.js b/netwerk/test/unit/test_httpcancel.js
--- a/netwerk/test/unit/test_httpcancel.js
+++ b/netwerk/test/unit/test_httpcancel.js
@@ -85,29 +85,30 @@ function makeChan(url) {
   chan.referrer = uri;
 
   return chan;
 }
 
 var httpserv = null;
 
 function execute_test() {
-  var chan = makeChan("http://localhost:4444/failtest");
+  var chan = makeChan("http://localhost:" +
+                      httpserv.identity.primaryPort + "/failtest");
 
   var obs = Components.classes["@mozilla.org/observer-service;1"].getService();
   obs = obs.QueryInterface(Components.interfaces.nsIObserverService);
   obs.addObserver(observer, "http-on-modify-request", false);
 
   chan.asyncOpen(listener, null);
 }
 
 function run_test() {
   httpserv = new HttpServer();
   httpserv.registerPathHandler("/failtest", failtest);
-  httpserv.start(4444);
+  httpserv.start(-1);
 
   execute_test();
 
   do_test_pending();
 }
 
 // PATHS
 
diff --git a/netwerk/test/unit/test_httpsuspend.js b/netwerk/test/unit/test_httpsuspend.js
--- a/netwerk/test/unit/test_httpsuspend.js
+++ b/netwerk/test/unit/test_httpsuspend.js
@@ -3,16 +3,20 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserv.identity.primaryPort;
+});
+
 const MIN_TIME_DIFFERENCE = 3000;
 const RESUME_DELAY = 5000;
 
 var listener = {
   _lastEvent: 0,
   _gotData: false,
 
   QueryInterface: function(iid) {
@@ -60,19 +64,19 @@ function makeChan(url) {
   return chan;
 }
 
 var httpserv = null;
 
 function run_test() {
   httpserv = new HttpServer();
   httpserv.registerPathHandler("/woo", data);
-  httpserv.start(4444);
+  httpserv.start(-1);
 
-  var chan = makeChan("http://localhost:4444/woo");
+  var chan = makeChan(URL + "/woo");
   chan.QueryInterface(Ci.nsIRequest);
   chan.asyncOpen(listener, null);
 
   do_test_pending();
 }
 
 function data(metadata, response) {
   let httpbody = "0123456789";
diff --git a/netwerk/test/unit/test_mismatch_last-modified.js b/netwerk/test/unit/test_mismatch_last-modified.js
--- a/netwerk/test/unit/test_mismatch_last-modified.js
+++ b/netwerk/test/unit/test_mismatch_last-modified.js
@@ -41,17 +41,18 @@ var listener_3 = {
 	do_check_eq(data[0], "B".charCodeAt(0));
     },
 
     onStopRequest: function test_onStopR(request, ctx, status) {
 	httpserver.stop(do_test_finished);
     }
 };
 
-var listener_2 = {
+XPCOMUtils.defineLazyGetter(this, "listener_2", function() {
+    return {
     // this listener is used to process the revalidation of the
     // corrupted cache entry. its revalidation prompts it to be cleaned
 
     QueryInterface: function(iid) {
 	if (iid.equals(Components.interfaces.nsIStreamListener) ||
             iid.equals(Components.interfaces.nsIRequestObserver) ||
             iid.equals(Components.interfaces.nsISupports))
 	    return this;
@@ -68,22 +69,26 @@ var listener_2 = {
 	// because of mismatched last-modified response headers
 	
 	do_check_eq(data[0], "A".charCodeAt(0));
     },
 
     onStopRequest: function test_onStopR(request, ctx, status) {
 	var channel = request.QueryInterface(Ci.nsIHttpChannel);
 
-	var chan = ios.newChannel("http://localhost:4444/test1", "", null);
+	var chan = ios.newChannel("http://localhost:" +
+				  httpserver.identity.primaryPort +
+				  "/test1", "", null);
 	chan.asyncOpen(listener_3, null);
     }
 };
+});
 
-var listener_1 = {
+XPCOMUtils.defineLazyGetter(this, "listener_1", function() {
+    return {
     // this listener processes the initial request from a empty cache.
     // the server responds with the wrong data ('A')
 
     QueryInterface: function(iid) {
 	if (iid.equals(Components.interfaces.nsIStreamListener) ||
             iid.equals(Components.interfaces.nsIRequestObserver) ||
             iid.equals(Components.interfaces.nsISupports))
 	    return this;
@@ -96,32 +101,37 @@ var listener_1 = {
                                        offset, count) {
 	var data = new BinaryInputStream(inputStream).readByteArray(count);
 	do_check_eq(data[0], "A".charCodeAt(0));
     },
 
     onStopRequest: function test_onStopR(request, ctx, status) {
 	var channel = request.QueryInterface(Ci.nsIHttpChannel);
 
-	var chan = ios.newChannel("http://localhost:4444/test1", "", null);
+	var chan = ios.newChannel("http://localhost:" +
+				  httpserver.identity.primaryPort +
+				  "/test1", "", null);
 	chan.asyncOpen(listener_2, null);
     }
 };
+});
 
 function run_test() {
     do_get_profile();
     ios = Cc["@mozilla.org/network/io-service;1"]
             .getService(Ci.nsIIOService);
 
     evict_cache_entries();
 
     httpserver.registerPathHandler("/test1", handler);
-    httpserver.start(4444);
+    httpserver.start(-1);
 
-    var chan = ios.newChannel("http://localhost:4444/test1", "", null);
+    var port = httpserver.identity.primaryPort;
+
+    var chan = ios.newChannel("http://localhost:" + port + "/test1", "", null);
     chan.asyncOpen(listener_1, null);
 
     do_test_pending();
 }
 
 var iter=0;
 function handler(metadata, response) {
     iter++;
diff --git a/netwerk/test/unit/test_multipart_byteranges.js b/netwerk/test/unit/test_multipart_byteranges.js
--- a/netwerk/test/unit/test_multipart_byteranges.js
+++ b/netwerk/test/unit/test_multipart_byteranges.js
@@ -1,17 +1,20 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpserver = null;
-var uri = "http://localhost:4444/multipart";
+
+XPCOMUtils.defineLazyGetter(this, "uri", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort + "/multipart";
+});
 
 function make_channel(url) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 var multipartBody = "--boundary\r\n"+
@@ -102,17 +105,17 @@ var multipartListener = {
     }
   }
 };
 
 function run_test()
 {
   httpserver = new HttpServer();
   httpserver.registerPathHandler("/multipart", contentHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   var streamConv = Cc["@mozilla.org/streamConverters;1"]
                      .getService(Ci.nsIStreamConverterService);
   var conv = streamConv.asyncConvertData("multipart/byteranges",
 					 "*/*",
 					 multipartListener,
 					 null);
 
diff --git a/netwerk/test/unit/test_multipart_streamconv.js b/netwerk/test/unit/test_multipart_streamconv.js
--- a/netwerk/test/unit/test_multipart_streamconv.js
+++ b/netwerk/test/unit/test_multipart_streamconv.js
@@ -1,17 +1,20 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpserver = null;
-var uri = "http://localhost:4444/multipart";
+
+XPCOMUtils.defineLazyGetter(this, "uri", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort + "/multipart";
+});
 
 function make_channel(url) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 var multipartBody = "--boundary\r\n\r\nSome text\r\n--boundary\r\n\r\n<?xml version='1.0'?><root/>\r\n--boundary--";
@@ -78,17 +81,17 @@ var multipartListener = {
     }
   }
 };
 
 function run_test()
 {
   httpserver = new HttpServer();
   httpserver.registerPathHandler("/multipart", contentHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   var streamConv = Cc["@mozilla.org/streamConverters;1"]
                      .getService(Ci.nsIStreamConverterService);
   var conv = streamConv.asyncConvertData("multipart/mixed",
 					 "*/*",
 					 multipartListener,
 					 null);
 
diff --git a/netwerk/test/unit/test_multipart_streamconv_missing_lead_boundary.js b/netwerk/test/unit/test_multipart_streamconv_missing_lead_boundary.js
--- a/netwerk/test/unit/test_multipart_streamconv_missing_lead_boundary.js
+++ b/netwerk/test/unit/test_multipart_streamconv_missing_lead_boundary.js
@@ -1,17 +1,20 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
 var httpserver = null;
-var uri = "http://localhost:4444/multipart";
+
+XPCOMUtils.defineLazyGetter(this, "uri", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort + "/multipart";
+});
 
 function make_channel(url) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 var multipartBody = "\r\nSome text\r\n--boundary\r\n\r\n<?xml version='1.0'?><root/>\r\n--boundary--";
@@ -78,17 +81,17 @@ var multipartListener = {
     }
   }
 };
 
 function run_test()
 {
   httpserver = new HttpServer();
   httpserver.registerPathHandler("/multipart", contentHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   var streamConv = Cc["@mozilla.org/streamConverters;1"]
                      .getService(Ci.nsIStreamConverterService);
   var conv = streamConv.asyncConvertData("multipart/mixed",
 					 "*/*",
 					 multipartListener,
 					 null);
 
diff --git a/netwerk/test/unit/test_nojsredir.js b/netwerk/test/unit/test_nojsredir.js
--- a/netwerk/test/unit/test_nojsredir.js
+++ b/netwerk/test/unit/test_nojsredir.js
@@ -17,17 +17,18 @@ var tests = [
      responseheader: [ "Location: javascript:alert()"],
      flags : CL_EXPECT_FAILURE,
      datalen : 0},
 ];
 
 function setupChannel(url) {
     var ios = Components.classes["@mozilla.org/network/io-service;1"].
                          getService(Ci.nsIIOService);
-    var chan = ios.newChannel("http://localhost:4444" + url, "", null);
+    var chan = ios.newChannel("http://localhost:" +
+			      httpserver.identity.primaryPort + url, "", null);
     return chan;
 }
 
 function startIter() {
     var channel = setupChannel(tests[index].url);
     channel.asyncOpen(new ChannelListener(completeIter, channel, tests[index].flags), null);
 }
 
@@ -37,17 +38,17 @@ function completeIter(request, data, ctx
 	startIter();
     } else {
         httpserver.stop(do_test_finished);
     }
 }
 
 function run_test() {
     httpserver.registerPathHandler("/test/test", handler);
-    httpserver.start(4444);
+    httpserver.start(-1);
 
     startIter();
     do_test_pending();
 }
 
 function handler(metadata, response) {
     var body = "thequickbrownfox";
     response.setHeader("Content-Type", "text/plain", false);
diff --git a/netwerk/test/unit/test_pinned_app_cache.js b/netwerk/test/unit/test_pinned_app_cache.js
--- a/netwerk/test/unit/test_pinned_app_cache.js
+++ b/netwerk/test/unit/test_pinned_app_cache.js
@@ -52,18 +52,24 @@ const kManifest1 = "CACHE MANIFEST\n" +
 const kManifest2 = "CACHE MANIFEST\n" +
   "/pages/foo5\n" +
   "/pages/foo6\n" +
   "/pages/foo7\n" +
   "/pages/foo8\n";
 
 const kDataFileSize = 1024;	// file size for each content page
 const kCacheSize = kDataFileSize * 5; // total space for offline cache storage
-const kHttpLocation = "http://localhost:4444/";
-const kHttpLocation_ip = "http://127.0.0.1:4444/";
+
+XPCOMUtils.defineLazyGetter(this, "kHttpLocation", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort + "/";
+});
+
+XPCOMUtils.defineLazyGetter(this, "kHttpLocation_ip", function() {
+  return "http://127.0.0.1:" + httpServer.identity.primaryPort + "/";
+});
 
 function manifest1_handler(metadata, response) {
   do_print("manifest1\n");
   response.setHeader("content-type", "text/cache-manifest");
 
   response.write(kManifest1);
 }
 
@@ -108,17 +114,17 @@ function init_http_server() {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/app1", app_handler);
   httpServer.registerPathHandler("/app2", app_handler);
   httpServer.registerPathHandler("/app1.appcache", manifest1_handler);
   httpServer.registerPathHandler("/app2.appcache", manifest2_handler);
   for (i = 1; i <= 8; i++) {
     httpServer.registerPathHandler("/pages/foo" + i, datafile_handler);
   }
-  httpServer.start(4444);
+  httpServer.start(-1);
 }
 
 function init_cache_capacity() {
   let prefs = Cc["@mozilla.org/preferences-service;1"]
     .getService(Components.interfaces.nsIPrefBranch);
   prefs.setIntPref("browser.cache.offline.capacity", kCacheSize / 1024);
 }
 
diff --git a/netwerk/test/unit/test_plaintext_sniff.js b/netwerk/test/unit/test_plaintext_sniff.js
--- a/netwerk/test/unit/test_plaintext_sniff.js
+++ b/netwerk/test/unit/test_plaintext_sniff.js
@@ -76,18 +76,18 @@ for (i = 0; i <= 127; ++i) {
                     BOMList[j].length == 2 && isBinaryChar(i) ]);
   }
 }
 
 function makeChan(headerIdx, bodyIdx) {
   var ios = Components.classes["@mozilla.org/network/io-service;1"]
                       .getService(Components.interfaces.nsIIOService);
   var chan =
-    ios.newChannel("http://localhost:4444/" + headerIdx + "/" + bodyIdx, null,
-                   null)
+    ios.newChannel("http://localhost:" + httpserv.identity.primaryPort +
+                   "/" + headerIdx + "/" + bodyIdx, null, null)
        .QueryInterface(Components.interfaces.nsIHttpChannel);
 
   chan.loadFlags |=
     Components.interfaces.nsIChannel.LOAD_CALL_CONTENT_SNIFFERS;
 
   return chan;
 }
 
@@ -188,12 +188,12 @@ function run_test() {
   httpserv = new HttpServer();
 
   for (i = 0; i < contentTypeHeaderList.length; ++i) {
     for (j = 0; j < bodyList.length; ++j) {
       httpserv.registerPathHandler("/" + i + "/" + j, makeHandler(i, j));
     }
   }
 
-  httpserv.start(4444);
+  httpserv.start(-1);
 
   doTest(0, 0);
 }
diff --git a/netwerk/test/unit/test_post.js b/netwerk/test/unit/test_post.js
--- a/netwerk/test/unit/test_post.js
+++ b/netwerk/test/unit/test_post.js
@@ -4,16 +4,20 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort;
+});
+
 var httpserver = new HttpServer();
 var testpath = "/simple";
 
 var testfile = do_get_file("../unit/data/test_readline6.txt");
 
 const BOUNDARY = "AaB03x";
 var teststring1 = "--" + BOUNDARY + "\r\n"
                 + "Content-Disposition: form-data; name=\"body\"\r\n\r\n"
@@ -51,32 +55,32 @@ function run_test() {
 
   var mime = Cc["@mozilla.org/network/mime-input-stream;1"].
                createInstance(Ci.nsIMIMEInputStream);
   mime.addHeader("Content-Type", "multipart/form-data; boundary="+BOUNDARY);
   mime.setData(multi);
   mime.addContentLength = true;
 
   httpserver.registerPathHandler(testpath, serverHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   var channel = setupChannel(testpath);
 
   channel.QueryInterface(Ci.nsIUploadChannel)
          .setUploadStream(mime, "", mime.available());
   channel.requestMethod = "POST";
 
   channel.asyncOpen(new ChannelListener(checkRequest, channel), null);
 
   do_test_pending();
 }
 
 function setupChannel(path) {
   var ios = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
-  return chan = ios.newChannel("http://localhost:4444" + path, "", null)
+  return chan = ios.newChannel(URL + path, "", null)
                    .QueryInterface(Ci.nsIHttpChannel);
 }
 
 function serverHandler(metadata, response) {
   do_check_eq(metadata.method, "POST");
 
   var data = read_stream(metadata.bodyInputStream,
 			 metadata.bodyInputStream.available());
diff --git a/netwerk/test/unit/test_private_necko_channel.js b/netwerk/test/unit/test_private_necko_channel.js
--- a/netwerk/test/unit/test_private_necko_channel.js
+++ b/netwerk/test/unit/test_private_necko_channel.js
@@ -16,32 +16,33 @@ var httpbody = "0123456789";
 function run_test() {
   // Simulate a profile dir for xpcshell
   do_get_profile();
 
   // Start off with an empty cache
   evict_cache_entries();
 
   httpserver.registerPathHandler(testpath, serverHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   var channel = setupChannel(testpath);
   channel.loadGroup = Cc["@mozilla.org/network/load-group;1"].createInstance();
 
   channel.QueryInterface(Ci.nsIPrivateBrowsingChannel);
   channel.setPrivate(true);
 
   channel.asyncOpen(new ChannelListener(checkRequest, channel), null);
 
   do_test_pending();
 }
 
 function setupChannel(path) {
   var ios = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
-  return chan = ios.newChannel("http://localhost:4444" + path, "", null)
+  return chan = ios.newChannel("http://localhost:" +
+                               httpserver.identity.primaryPort + path, "", null)
                    .QueryInterface(Ci.nsIHttpChannel);
 }
 
 function serverHandler(metadata, response) {
   response.setHeader("Content-Type", "text/plain", false);
   response.bodyOutputStream.write(httpbody, httpbody.length);
 }
 
diff --git a/netwerk/test/unit/test_progress.js b/netwerk/test/unit/test_progress.js
--- a/netwerk/test/unit/test_progress.js
+++ b/netwerk/test/unit/test_progress.js
@@ -1,15 +1,19 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort;
+});
+
 var httpserver = new HttpServer();
 var testpath = "/simple";
 var httpbody = "0123456789";
 
 var last = 0, max = 0;
 
 const STATUS_RECEIVING_FROM = 0x804b0006;
 const LOOPS = 50000;
@@ -93,26 +97,26 @@ var progressCallback = {
     mStatus = status;
   },
 
   mStatus: 0,
 };
 
 function run_test() {
   httpserver.registerPathHandler(testpath, serverHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
   var channel = setupChannel(testpath);
   channel.asyncOpen(progressCallback, null);
   do_test_pending();
 }
 
 function setupChannel(path) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
                        getService(Ci.nsIIOService);
-  var chan = ios.newChannel("http://localhost:4444" + path, "", null);
+  var chan = ios.newChannel(URL + path, "", null);
   chan.QueryInterface(Ci.nsIHttpChannel);
   chan.requestMethod = "GET";
   chan.notificationCallbacks = progressCallback;
   return chan;
 }
 
 function serverHandler(metadata, response) {
   response.setHeader("Content-Type", "text/plain", false);
diff --git a/netwerk/test/unit/test_proxy-failover_canceled.js b/netwerk/test/unit/test_proxy-failover_canceled.js
--- a/netwerk/test/unit/test_proxy-failover_canceled.js
+++ b/netwerk/test/unit/test_proxy-failover_canceled.js
@@ -26,29 +26,31 @@ function finish_test(request, buffer)
   do_check_eq(buffer, "");
   httpServer.stop(do_test_finished);
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/content", contentHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   // we want to cancel the failover proxy engage, so, do not allow
   // redirects from now.
 
   var nc = new ChannelEventSink();
   nc._flags = ES_ABORT_REDIRECT;
 
   var prefserv = Cc["@mozilla.org/preferences-service;1"].
                  getService(Ci.nsIPrefService);
   var prefs = prefserv.getBranch("network.proxy.");
   prefs.setIntPref("type", 2);
   prefs.setCharPref("autoconfig_url", "data:text/plain," +
-    "function FindProxyForURL(url, host) {return 'PROXY a_non_existent_domain_x7x6c572v:80; PROXY localhost:4444';}"
+    "function FindProxyForURL(url, host) {return 'PROXY a_non_existent_domain_x7x6c572v:80; PROXY localhost:" +
+    httpServer.identity.primaryPort + "';}"
   );
 
-  var chan = make_channel("http://localhost:4444/content");
+  var chan = make_channel("http://localhost:" +
+                          httpServer.identity.primaryPort + "/content");
   chan.notificationCallbacks = nc;
   chan.asyncOpen(new ChannelListener(finish_test, null, CL_EXPECT_FAILURE), null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_proxy-failover_passing.js b/netwerk/test/unit/test_proxy-failover_passing.js
--- a/netwerk/test/unit/test_proxy-failover_passing.js
+++ b/netwerk/test/unit/test_proxy-failover_passing.js
@@ -26,22 +26,24 @@ function finish_test(request, buffer)
   do_check_eq(buffer, responseBody);
   httpServer.stop(do_test_finished);
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/content", contentHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var prefserv = Cc["@mozilla.org/preferences-service;1"].
                  getService(Ci.nsIPrefService);
   var prefs = prefserv.getBranch("network.proxy.");
   prefs.setIntPref("type", 2);
   prefs.setCharPref("autoconfig_url", "data:text/plain," +
-    "function FindProxyForURL(url, host) {return 'PROXY a_non_existent_domain_x7x6c572v:80; PROXY localhost:4444';}"
+    "function FindProxyForURL(url, host) {return 'PROXY a_non_existent_domain_x7x6c572v:80; PROXY localhost:" +
+    httpServer.identity.primaryPort + "';}"
   );
 
-  var chan = make_channel("http://localhost:4444/content");
+  var chan = make_channel("http://localhost:" +
+                          httpServer.identity.primaryPort + "/content");
   chan.asyncOpen(new ChannelListener(finish_test, null), null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_proxy-replace_canceled.js b/netwerk/test/unit/test_proxy-replace_canceled.js
--- a/netwerk/test/unit/test_proxy-replace_canceled.js
+++ b/netwerk/test/unit/test_proxy-replace_canceled.js
@@ -26,31 +26,33 @@ function finish_test(request, buffer)
   do_check_eq(buffer, "");
   httpServer.stop(do_test_finished);
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/content", contentHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var prefserv = Cc["@mozilla.org/preferences-service;1"].
                  getService(Ci.nsIPrefService);
   var prefs = prefserv.getBranch("network.proxy.");
   prefs.setIntPref("type", 2);
   prefs.setCharPref("autoconfig_url", "data:text/plain," +
-    "function FindProxyForURL(url, host) {return 'PROXY localhost:4444';}"
+    "function FindProxyForURL(url, host) {return 'PROXY localhost:" +
+    httpServer.identity.primaryPort + "';}"
   );
 
   // this test assumed that a AsyncOnChannelRedirect query is made for
   // each proxy failover or on the inital proxy only when PAC mode is used.
   // Neither of those are documented anywhere that I can find and the latter
   // hasn't been a useful property because it is PAC dependent and the type
   // is generally unknown and OS driven. 769764 changed that to remove the
   // internal redirect used to setup the initial proxy/channel as that isn't
   // a redirect in any sense.
 
-  var chan = make_channel("http://localhost:4444/content");
+  var chan = make_channel("http://localhost:" +
+                          httpServer.identity.primaryPort + "/content");
   chan.asyncOpen(new ChannelListener(finish_test, null, CL_EXPECT_FAILURE), null);
   chan.cancel(Cr.NS_BINDING_ABORTED);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_proxy-replace_passing.js b/netwerk/test/unit/test_proxy-replace_passing.js
--- a/netwerk/test/unit/test_proxy-replace_passing.js
+++ b/netwerk/test/unit/test_proxy-replace_passing.js
@@ -26,22 +26,24 @@ function finish_test(request, buffer)
   do_check_eq(buffer, responseBody);
   httpServer.stop(do_test_finished);
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/content", contentHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var prefserv = Cc["@mozilla.org/preferences-service;1"].
                  getService(Ci.nsIPrefService);
   var prefs = prefserv.getBranch("network.proxy.");
   prefs.setIntPref("type", 2);
   prefs.setCharPref("autoconfig_url", "data:text/plain," +
-    "function FindProxyForURL(url, host) {return 'PROXY localhost:4444';}"
+    "function FindProxyForURL(url, host) {return 'PROXY localhost:" +
+    httpServer.identity.primaryPort + "';}"
   );
 
-  var chan = make_channel("http://localhost:4444/content");
+  var chan = make_channel("http://localhost:" +
+                          httpServer.identity.primaryPort + "/content");
   chan.asyncOpen(new ChannelListener(finish_test, null), null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_range_requests.js b/netwerk/test/unit/test_range_requests.js
--- a/netwerk/test/unit/test_range_requests.js
+++ b/netwerk/test/unit/test_range_requests.js
@@ -28,16 +28,17 @@ const clearTextBody = "This is a slightl
 const encodedBody = [0x1f, 0x8b, 0x08, 0x08, 0xef, 0x70, 0xe6, 0x4c, 0x00, 0x03, 0x74, 0x65, 0x78, 0x74, 0x66, 0x69,
                      0x6c, 0x65, 0x2e, 0x74, 0x78, 0x74, 0x00, 0x0b, 0xc9, 0xc8, 0x2c, 0x56, 0x00, 0xa2, 0x44, 0x85,
                      0xe2, 0x9c, 0xcc, 0xf4, 0x8c, 0x92, 0x9c, 0x4a, 0x85, 0x9c, 0xfc, 0xbc, 0xf4, 0xd4, 0x22, 0x85,
                      0x92, 0xd4, 0xe2, 0x12, 0x2e, 0x2e, 0x00, 0x00, 0xe5, 0xe6, 0xf0, 0x20, 0x00, 0x00, 0x00];
 const decodedBody = [0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x6c, 0x69, 0x67, 0x68, 0x74,
                      0x6c, 0x79, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x74, 0x65, 0x73, 0x74, 0x0a, 0x0a];
 
 const partial_data_length = 4;
+var port = null; // set in run_test
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   var chan = ios.newChannel(url, "", null);
   return chan.QueryInterface(Ci.nsIHttpChannel);
 }
 
@@ -102,17 +103,17 @@ function setStdHeaders(response, length)
 
 function handler_2(metadata, response) {
   setStdHeaders(response, clearTextBody.length);
   do_check_false(metadata.hasHeader("Range"));
   response.bodyOutputStream.write(clearTextBody, clearTextBody.length);
 }
 function received_partial_2(request, data) {
   do_check_eq(data, undefined);
-  var chan = make_channel("http://localhost:4444/test_2");
+  var chan = make_channel("http://localhost:" + port + "/test_2");
   chan.asyncOpen(new ChannelListener(received_cleartext, null), null);
 }
 
 var case_3_request_no = 0;
 function handler_3(metadata, response) {
   var body = clearTextBody;
   setStdHeaders(response, body.length);
   response.setHeader("Cache-Control", "no-store", false);
@@ -130,17 +131,17 @@ function handler_3(metadata, response) {
       break;
     default:
       response.setStatusLine(metadata.httpVersion, 404, "Not Found");
   }
   case_3_request_no++;
 }
 function received_partial_3(request, data) {
   do_check_eq(partial_data_length, data.length);
-  var chan = make_channel("http://localhost:4444/test_3");
+  var chan = make_channel("http://localhost:" + port + "/test_3");
   chan.asyncOpen(new ChannelListener(received_cleartext, null), null);
 }
 
 var case_4_request_no = 0;
 function handler_4(metadata, response) {
   switch (case_4_request_no) {
     case 0:
       do_check_false(metadata.hasHeader("Range"));
@@ -163,17 +164,17 @@ function handler_4(metadata, response) {
     default:
       response.setStatusLine(metadata.httpVersion, 404, "Not Found");
   }
   case_4_request_no++;
 }
 function received_partial_4(request, data) {
 // checking length does not work with encoded data
 //  do_check_eq(partial_data_length, data.length);
-  var chan = make_channel("http://localhost:4444/test_4");
+  var chan = make_channel("http://localhost:" + port + "/test_4");
   chan.asyncOpen(new MyListener(received_cleartext), null);
 }
 
 var case_5_request_no = 0;
 function handler_5(metadata, response) {
   var body = clearTextBody;
   setStdHeaders(response, body.length);
   switch (case_5_request_no) {
@@ -190,17 +191,17 @@ function handler_5(metadata, response) {
       break;
     default:
       response.setStatusLine(metadata.httpVersion, 404, "Not Found");
   }
   case_5_request_no++;
 }
 function received_partial_5(request, data) {
   do_check_eq(partial_data_length, data.length);
-  var chan = make_channel("http://localhost:4444/test_5");
+  var chan = make_channel("http://localhost:" + port + "/test_5");
   chan.setRequestHeader("If-Match", "Some eTag", false);
   chan.asyncOpen(new ChannelListener(received_cleartext, null), null);
 }
 
 var case_6_request_no = 0;
 function handler_6(metadata, response) {
   switch (case_6_request_no) {
     case 0:
@@ -221,17 +222,17 @@ function handler_6(metadata, response) {
     default:
       response.setStatusLine(metadata.httpVersion, 404, "Not Found");
   }
   case_6_request_no++;
 }
 function received_partial_6(request, data) {
 // would like to verify that the response does not have Accept-Ranges
   do_check_eq(partial_data_length, data.length);
-  var chan = make_channel("http://localhost:4444/test_6");
+  var chan = make_channel("http://localhost:" + port + "/test_6");
   chan.asyncOpen(new ChannelListener(received_cleartext, null), null);
 }
 
 // Simple mechanism to keep track of tests and stop the server
 var numTestsFinished = 0;
 function testFinished() {
   if (++numTestsFinished == 5)
     httpserver.stop(do_test_finished);
@@ -239,35 +240,37 @@ function testFinished() {
 
 function run_test() {
   httpserver = new HttpServer();
   httpserver.registerPathHandler("/test_2", handler_2);
   httpserver.registerPathHandler("/test_3", handler_3);
   httpserver.registerPathHandler("/test_4", handler_4);
   httpserver.registerPathHandler("/test_5", handler_5);
   httpserver.registerPathHandler("/test_6", handler_6);
-  httpserver.start(4444);
+  httpserver.start(-1);
+
+  port = httpserver.identity.primaryPort;
 
   // wipe out cached content
   evict_cache_entries();
 
   // Case 2: zero-length partial entry must not trigger range-request
-  var chan = make_channel("http://localhost:4444/test_2");
+  var chan = make_channel("http://localhost:" + port + "/test_2");
   chan.asyncOpen(new Canceler(received_partial_2), null);
 
   // Case 3: no-store response must not trigger range-request
-  var chan = make_channel("http://localhost:4444/test_3");
+  var chan = make_channel("http://localhost:" + port + "/test_3");
   chan.asyncOpen(new MyListener(received_partial_3), null);
 
   // Case 4: response with content-encoding must not trigger range-request
-  var chan = make_channel("http://localhost:4444/test_4");
+  var chan = make_channel("http://localhost:" + port + "/test_4");
   chan.asyncOpen(new MyListener(received_partial_4), null);
 
   // Case 5: conditional request-header set by client
-  var chan = make_channel("http://localhost:4444/test_5");
+  var chan = make_channel("http://localhost:" + port + "/test_5");
   chan.asyncOpen(new MyListener(received_partial_5), null);
 
   // Case 6: response is not resumable (drop the Accept-Ranges header)
-  var chan = make_channel("http://localhost:4444/test_6");
+  var chan = make_channel("http://localhost:" + port + "/test_6");
   chan.asyncOpen(new MyListener(received_partial_6), null);
 
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_redirect-caching_canceled.js b/netwerk/test/unit/test_redirect-caching_canceled.js
--- a/netwerk/test/unit/test_redirect-caching_canceled.js
+++ b/netwerk/test/unit/test_redirect-caching_canceled.js
@@ -1,32 +1,39 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort;
+});
+
 var httpServer = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/redirect/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return URL + randomPath;
+});
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 const responseBody = "response body";
 
 function redirectHandler(metadata, response)
 {
   response.setStatusLine(metadata.httpVersion, 301, "Moved");
-  response.setHeader("Location", "http://localhost:4444/content", false);
+  response.setHeader("Location", URL + "/content", false);
   response.setHeader("Cache-control", "max-age=1000", false);
   return;
 }
 
 function contentHandler(metadata, response)
 {
   response.setHeader("Content-Type", "text/plain");
   response.bodyOutputStream.write(responseBody, responseBody.length);
@@ -54,14 +61,14 @@ function finish_test(request, buffer)
   httpServer.stop(do_test_finished);
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler(randomPath, redirectHandler);
   httpServer.registerPathHandler("/content", contentHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var chan = make_channel(randomURI);
   chan.asyncOpen(new ChannelListener(firstTimeThrough, null), null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_redirect-caching_failure.js b/netwerk/test/unit/test_redirect-caching_failure.js
--- a/netwerk/test/unit/test_redirect-caching_failure.js
+++ b/netwerk/test/unit/test_redirect-caching_failure.js
@@ -1,30 +1,38 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort;
+});
+
 var httpServer = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/redirect/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return URL + randomPath;
+});
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 function redirectHandler(metadata, response)
 {
   response.setStatusLine(metadata.httpVersion, 301, "Moved");
-  response.setHeader("Location", "httpx://localhost:4444/content", false);
+  response.setHeader("Location", "httpx://localhost:" +
+                     httpServer.identity.primaryPort + "/content", false);
   response.setHeader("Cache-control", "max-age=1000", false);
 }
 
 function makeSureNotInCache(request, buffer)
 {
   do_check_eq(request.status, Components.results.NS_ERROR_UNKNOWN_PROTOCOL);
 
   // It's very unlikely that we'd somehow succeed when we try again from cache.
@@ -40,14 +48,14 @@ function finish_test(request, buffer)
   do_check_eq(buffer, "");
   httpServer.stop(do_test_finished);
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler(randomPath, redirectHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var chan = make_channel(randomURI);
   chan.asyncOpen(new ChannelListener(makeSureNotInCache, null, CL_EXPECT_FAILURE), null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_redirect-caching_passing.js b/netwerk/test/unit/test_redirect-caching_passing.js
--- a/netwerk/test/unit/test_redirect-caching_passing.js
+++ b/netwerk/test/unit/test_redirect-caching_passing.js
@@ -1,32 +1,39 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort;
+});
+
 var httpserver = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/redirect/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return URL + randomPath;
+});
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 const responseBody = "response body";
 
 function redirectHandler(metadata, response)
 {
   response.setStatusLine(metadata.httpVersion, 301, "Moved");
-  response.setHeader("Location", "http://localhost:4444/content", false);
+  response.setHeader("Location", URL + "/content", false);
   return;
 }
 
 function contentHandler(metadata, response)
 {
   response.setHeader("Content-Type", "text/plain");
   response.bodyOutputStream.write(responseBody, responseBody.length);
 }
@@ -45,14 +52,14 @@ function finish_test(request, buffer)
   httpserver.stop(do_test_finished);
 }
 
 function run_test()
 {
   httpserver = new HttpServer();
   httpserver.registerPathHandler(randomPath, redirectHandler);
   httpserver.registerPathHandler("/content", contentHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   var chan = make_channel(randomURI);
   chan.asyncOpen(new ChannelListener(firstTimeThrough, null), null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_redirect_baduri.js b/netwerk/test/unit/test_redirect_baduri.js
--- a/netwerk/test/unit/test_redirect_baduri.js
+++ b/netwerk/test/unit/test_redirect_baduri.js
@@ -7,17 +7,19 @@ Cu.import("resource://testing-common/htt
 
 /*
  * Test whether we fail bad URIs in HTTP redirect as CORRUPTED_CONTENT.
  */
 
 var httpServer = null;
 
 var BadRedirectPath = "/BadRedirect";
-var BadRedirectURI = "http://localhost:4444" + BadRedirectPath;
+XPCOMUtils.defineLazyGetter(this, "BadRedirectURI", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort + BadRedirectPath;
+});
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 function BadRedirectHandler(metadata, response)
@@ -33,15 +35,15 @@ function checkFailed(request, buffer)
 
   httpServer.stop(do_test_finished);
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler(BadRedirectPath, BadRedirectHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var chan = make_channel(BadRedirectURI);
   chan.asyncOpen(new ChannelListener(checkFailed, null, CL_EXPECT_FAILURE),
                  null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_redirect_canceled.js b/netwerk/test/unit/test_redirect_canceled.js
--- a/netwerk/test/unit/test_redirect_canceled.js
+++ b/netwerk/test/unit/test_redirect_canceled.js
@@ -1,32 +1,39 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort;
+});
+
 var httpServer = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/redirect/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return URL + randomPath;
+});
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 const responseBody = "response body";
 
 function redirectHandler(metadata, response)
 {
   response.setStatusLine(metadata.httpVersion, 301, "Moved");
-  response.setHeader("Location", "http://localhost:4444/content", false);
+  response.setHeader("Location", URL + "/content", false);
 }
 
 function contentHandler(metadata, response)
 {
   response.setHeader("Content-Type", "text/plain");
   response.bodyOutputStream.write(responseBody, responseBody.length);
 }
 
@@ -36,15 +43,15 @@ function finish_test(request, buffer)
   httpServer.stop(do_test_finished);
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler(randomPath, redirectHandler);
   httpServer.registerPathHandler("/content", contentHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var chan = make_channel(randomURI);
   chan.notificationCallbacks = new ChannelEventSink(ES_ABORT_REDIRECT);
   chan.asyncOpen(new ChannelListener(finish_test, null), null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_redirect_failure.js b/netwerk/test/unit/test_redirect_failure.js
--- a/netwerk/test/unit/test_redirect_failure.js
+++ b/netwerk/test/unit/test_redirect_failure.js
@@ -1,43 +1,51 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort;
+});
+
 var httpServer = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/redirect/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return URL + randomPath;
+});
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 function redirectHandler(metadata, response)
 {
   response.setStatusLine(metadata.httpVersion, 301, "Moved");
-  response.setHeader("Location", "httpx://localhost:4444/content", false);
+  response.setHeader("Location", "httpx://localhost:" +
+                     httpServer.identity.primaryPort + "/content", false);
   response.setHeader("Cache-Control", "no-cache", false);
 }
 
 function finish_test(request, buffer)
 {
   do_check_eq(request.status, Components.results.NS_ERROR_UNKNOWN_PROTOCOL);
 
   do_check_eq(buffer, "");
   httpServer.stop(do_test_finished);
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler(randomPath, redirectHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var chan = make_channel(randomURI);
   chan.asyncOpen(new ChannelListener(finish_test, null, CL_EXPECT_FAILURE), null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_redirect_from_script.js b/netwerk/test/unit/test_redirect_from_script.js
--- a/netwerk/test/unit/test_redirect_from_script.js
+++ b/netwerk/test/unit/test_redirect_from_script.js
@@ -31,41 +31,62 @@ const Cr = Components.results;
 Cu.import("resource://testing-common/httpd.js");
 
 // the topic we observe to use the API.  http-on-opening-request might also
 // work for some purposes.
 redirectHook = "http-on-modify-request";
 
 var httpServer = null, httpServer2 = null;
 
+XPCOMUtils.defineLazyGetter(this, "port1", function() {
+  return httpServer.identity.primaryPort;
+});
+
+XPCOMUtils.defineLazyGetter(this, "port2", function() {
+  return httpServer2.identity.primaryPort;
+});
+
 // Test Part 1: a cross-path redirect on a single HTTP server
-// http://localhost:4444/bait -> http://localhost:4444/switch
+// http://localhost:port1/bait -> http://localhost:port1/switch
 var baitPath = "/bait";
-var baitURI = "http://localhost:4444" + baitPath;
+XPCOMUtils.defineLazyGetter(this, "baitURI", function() {
+  return "http://localhost:" + port1 + baitPath;
+});
 var baitText = "you got the worm";
 
 var redirectedPath = "/switch";
-var redirectedURI = "http://localhost:4444" + redirectedPath;
+XPCOMUtils.defineLazyGetter(this, "redirectedURI", function() {
+  return "http://localhost:" + port1 + redirectedPath;
+});
 var redirectedText = "worms are not tasty";
 
 // Test Part 2: Now, a redirect to a different server
-// http://localhost:4444/bait2 -> http://localhost:4445/switch
+// http://localhost:port1/bait2 -> http://localhost:port2/switch
 var bait2Path = "/bait2";
-var bait2URI = "http://localhost:4444" + bait2Path;
-var redirected2URI = "http://localhost:4445" + redirectedPath;
+XPCOMUtils.defineLazyGetter(this, "bait2URI", function() {
+  return "http://localhost:" + port1 + bait2Path;
+});
+
+XPCOMUtils.defineLazyGetter(this, "redirected2URI", function() {
+  return "http://localhost:" + port2 + redirectedPath;
+});
 
 // Test Part 3, begin with a serverside redirect that itself turns into an instance
 // of Test Part 1
 var bait3Path = "/bait3";
-var bait3URI = "http://localhost:4444" + bait3Path;
+XPCOMUtils.defineLazyGetter(this, "bait3URI", function() {
+  return "http://localhost:" + port1 + bait3Path;
+});
 
 // Test Part 4, begin with this client-side redirect and which then redirects
 // to an instance of Test Part 1
 var bait4Path = "/bait4";
-var bait4URI = "http://localhost:4444" + bait4Path;
+XPCOMUtils.defineLazyGetter(this, "bait4URI", function() {
+  return "http://localhost:" + port1 + bait4Path;
+});
 
 var testHeaderName = "X-Redirected-By-Script"
 var testHeaderVal = "Success";
 var testHeaderVal2 = "Success on server 2";
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
@@ -170,25 +191,22 @@ function makeAsyncTest(uri, headerValue,
   var test = function()
   {
     var chan = make_channel(uri);
     chan.asyncOpen(new ChannelListener(verifier), null);
   };
   return test;
 }
 
-
-// The tests depend on each other, and therefore need to be defined in the
-// reverse of the order they are called in.  It is therefore best to read this
-// stanza backwards!
-
-var testViaAsyncOpen4 = makeAsyncTest(bait4URI, testHeaderVal, done);
-var testViaAsyncOpen3 = makeAsyncTest(bait3URI, testHeaderVal, testViaAsyncOpen4);
-var testViaAsyncOpen2 = makeAsyncTest(bait2URI, testHeaderVal2, testViaAsyncOpen3);
-var testViaAsyncOpen  = makeAsyncTest(baitURI,  testHeaderVal, testViaAsyncOpen2);
+// will be defined in run_test because of the lazy getters,
+// since the server's port is defined dynamically
+var testViaAsyncOpen4 = null;
+var testViaAsyncOpen3 = null;
+var testViaAsyncOpen2 = null;
+var testViaAsyncOpen  = null;
 
 function testViaXHR()
 {
   runXHRTest(baitURI,  testHeaderVal);
   runXHRTest(bait2URI, testHeaderVal2);
   runXHRTest(bait3URI, testHeaderVal);
   runXHRTest(bait4URI, testHeaderVal);
 }
@@ -221,18 +239,26 @@ var redirector = new Redirector();
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler(baitPath, baitHandler);
   httpServer.registerPathHandler(bait2Path, baitHandler);
   httpServer.registerPathHandler(bait3Path, bait3Handler);
   httpServer.registerPathHandler(bait4Path, baitHandler);
   httpServer.registerPathHandler(redirectedPath, redirectedHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
   httpServer2 = new HttpServer();
   httpServer2.registerPathHandler(redirectedPath, redirected2Handler);
-  httpServer2.start(4445);
+  httpServer2.start(-1);
+
+  // The tests depend on each other, and therefore need to be defined in the
+  // reverse of the order they are called in.  It is therefore best to read this
+  // stanza backwards!
+  testViaAsyncOpen4 = makeAsyncTest(bait4URI, testHeaderVal, done);
+  testViaAsyncOpen3 = makeAsyncTest(bait3URI, testHeaderVal, testViaAsyncOpen4);
+  testViaAsyncOpen2 = makeAsyncTest(bait2URI, testHeaderVal2, testViaAsyncOpen3);
+  testViaAsyncOpen  = makeAsyncTest(baitURI,  testHeaderVal, testViaAsyncOpen2);
 
   testViaXHR();
   testViaAsyncOpen();  // will call done() asynchronously for cleanup
 
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_redirect_loop.js b/netwerk/test/unit/test_redirect_loop.js
--- a/netwerk/test/unit/test_redirect_loop.js
+++ b/netwerk/test/unit/test_redirect_loop.js
@@ -7,38 +7,40 @@ Cu.import("resource://testing-common/htt
 
 /*
  * This xpcshell test checks whether we detect infinite HTTP redirect loops.
  * We check loops with "Location:" set to 1) full URI, 2) relative URI, and 3)
  * empty Location header (which resolves to a relative link to the original
  * URI when the original URI ends in a slash).
  */
 
-var httpServer = null;
+var httpServer = new HttpServer();
+httpServer.start(-1);
+const PORT = httpServer.identity.primaryPort;
 
 var fullLoopPath = "/fullLoop"; 
-var fullLoopURI = "http://localhost:4444" + fullLoopPath;
+var fullLoopURI = "http://localhost:" + PORT + fullLoopPath;
 
 var relativeLoopPath = "/relativeLoop"; 
-var relativeLoopURI = "http://localhost:4444" + relativeLoopPath;
+var relativeLoopURI = "http://localhost:" + PORT + relativeLoopPath;
 
 // must use directory-style URI, so empty Location redirects back to self
 var emptyLoopPath = "/empty/";
-var emptyLoopURI = "http://localhost:4444" + emptyLoopPath;
+var emptyLoopURI = "http://localhost:" + PORT + emptyLoopPath;
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 function fullLoopHandler(metadata, response)
 {
   response.setStatusLine(metadata.httpVersion, 301, "Moved");
-  response.setHeader("Location", "http://localhost:4444/fullLoop", false);
+  response.setHeader("Location", "http://localhost:" + PORT + "/fullLoop", false);
 }
 
 function relativeLoopHandler(metadata, response)
 {
   response.setStatusLine(metadata.httpVersion, 301, "Moved");
   response.setHeader("Location", "relativeLoop", false);
 }
 
@@ -77,19 +79,17 @@ function testEmptyLoop(request, buffer)
 {
   do_check_eq(request.status, Components.results.NS_ERROR_REDIRECT_LOOP);
 
   httpServer.stop(do_test_finished);
 }
 
 function run_test()
 {
-  httpServer = new HttpServer();
   httpServer.registerPathHandler(fullLoopPath, fullLoopHandler);
   httpServer.registerPathHandler(relativeLoopPath, relativeLoopHandler);
   httpServer.registerPathHandler(emptyLoopPath, emptyLoopHandler);
-  httpServer.start(4444);
 
   var chan = make_channel(fullLoopURI);
   chan.asyncOpen(new ChannelListener(testFullLoop, null, CL_EXPECT_FAILURE),
                  null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_redirect_passing.js b/netwerk/test/unit/test_redirect_passing.js
--- a/netwerk/test/unit/test_redirect_passing.js
+++ b/netwerk/test/unit/test_redirect_passing.js
@@ -1,32 +1,39 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpServer.identity.primaryPort;
+});
+
 var httpServer = null;
 // Need to randomize, because apparently no one clears our cache
 var randomPath = "/redirect/" + Math.random();
-var randomURI = "http://localhost:4444" + randomPath;
+
+XPCOMUtils.defineLazyGetter(this, "randomURI", function() {
+  return URL + randomPath;
+});
 
 function make_channel(url, callback, ctx) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
             getService(Ci.nsIIOService);
   return ios.newChannel(url, "", null);
 }
 
 const responseBody = "response body";
 
 function redirectHandler(metadata, response)
 {
   response.setStatusLine(metadata.httpVersion, 301, "Moved");
-  response.setHeader("Location", "http://localhost:4444/content", false);
+  response.setHeader("Location", URL + "/content", false);
 }
 
 function contentHandler(metadata, response)
 {
   response.setHeader("Content-Type", "text/plain");
   response.bodyOutputStream.write(responseBody, responseBody.length);
 }
 
@@ -43,14 +50,14 @@ function finish_test(request, buffer)
   httpServer.stop(do_test_finished);
 }
 
 function run_test()
 {
   httpServer = new HttpServer();
   httpServer.registerPathHandler(randomPath, redirectHandler);
   httpServer.registerPathHandler("/content", contentHandler);
-  httpServer.start(4444);
+  httpServer.start(-1);
 
   var chan = make_channel(randomURI);
   chan.asyncOpen(new ChannelListener(firstTimeThrough, null), null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_reentrancy.js b/netwerk/test/unit/test_reentrancy.js
--- a/netwerk/test/unit/test_reentrancy.js
+++ b/netwerk/test/unit/test_reentrancy.js
@@ -1,24 +1,28 @@
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort;
+});
+
 var httpserver = new HttpServer();
 var testpath = "/simple";
 var httpbody = "<?xml version='1.0' ?><root>0123456789</root>";
 
 function syncXHR()
 {
   var xhr = Cc["@mozilla.org/xmlextras/xmlhttprequest;1"]
             .createInstance(Ci.nsIXMLHttpRequest);
-  xhr.open("GET", "http://localhost:4444" + testpath, false);
+  xhr.open("GET", URL + testpath, false);
   xhr.send(null);    
 }
 
 const MAX_TESTS = 2;
 
 var listener = {
   _done_onStart: false,
   _done_onData: false,
@@ -79,25 +83,25 @@ var listener = {
 function makeChan(url) {
   var ios = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);
   var chan = ios.newChannel(url, null, null).QueryInterface(Ci.nsIHttpChannel);
   return chan;
 }
 
 function next_test()
 {
-  var chan = makeChan("http://localhost:4444" + testpath);
+  var chan = makeChan(URL + testpath);
   chan.QueryInterface(Ci.nsIRequest);
   chan.asyncOpen(listener, null);
 }
 
 function run_test()
 {
   httpserver.registerPathHandler(testpath, serverHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   next_test();
 
   do_test_pending();
 }
 
 function serverHandler(metadata, response)
 {
diff --git a/netwerk/test/unit/test_reopen.js b/netwerk/test/unit/test_reopen.js
--- a/netwerk/test/unit/test_reopen.js
+++ b/netwerk/test/unit/test_reopen.js
@@ -108,17 +108,17 @@ function test_channel(createChanClosure)
 function test_data_channel() {
   test_channel(function() {
     return makeChan("data:text/plain,foo");
   });
 }
 
 function test_http_channel() {
   test_channel(function() {
-    return makeChan("http://localhost:4444/");
+    return makeChan("http://localhost:" + httpserv.identity.primaryPort + "/");
   });
 }
 
 function test_file_channel() {
   var file = do_get_file("data/test_readline1.txt");
   test_channel(function() {
     return new_file_channel(file);
   });
@@ -133,12 +133,12 @@ function test_ftp_channel() {
 
 function end() {
   httpserv.stop(do_test_finished);
 }
 
 function run_test() {
   // start server
   httpserv = new HttpServer();
-  httpserv.start(4444);
+  httpserv.start(-1);
 
   run_next_test();
 }
diff --git a/netwerk/test/unit/test_resumable_channel.js b/netwerk/test/unit/test_resumable_channel.js
--- a/netwerk/test/unit/test_resumable_channel.js
+++ b/netwerk/test/unit/test_resumable_channel.js
@@ -2,16 +2,20 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
+XPCOMUtils.defineLazyGetter(this, "URL", function() {
+  return "http://localhost:" + httpserver.identity.primaryPort;
+});
+
 var httpserver = null;
 
 const NS_ERROR_ENTITY_CHANGED = 0x804b0020;
 const NS_ERROR_NOT_RESUMABLE = 0x804b0019;
 
 const rangeBody = "Body of the range request handler.\r\n";
 
 function make_channel(url, callback, ctx) {
@@ -85,232 +89,234 @@ function run_test() {
   function get_entity_id(request, data, ctx) {
     dump("*** get_entity_id()\n");
     do_check_true(request instanceof Ci.nsIResumableChannel,
                   "must be a resumable channel");
     entityID = request.entityID;
     dump("*** entity id = " + entityID + "\n");
 
     // Try a non-resumable URL (responds with 200)
-    var chan = make_channel("http://localhost:4444/");
+    var chan = make_channel(URL);
     chan.nsIResumableChannel.resumeAt(1, entityID);
     chan.asyncOpen(new ChannelListener(try_resume, null, CL_EXPECT_FAILURE), null);
   }
 
   function try_resume(request, data, ctx) {
     dump("*** try_resume()\n");
     do_check_eq(request.status, NS_ERROR_NOT_RESUMABLE);
 
     // Try a successful resume
-    var chan = make_channel("http://localhost:4444/range");
+    var chan = make_channel(URL + "/range");
     chan.nsIResumableChannel.resumeAt(1, entityID);
     chan.asyncOpen(new ChannelListener(try_resume_zero, null), null);
   }
 
   function try_resume_zero(request, data, ctx) {
     dump("*** try_resume_zero()\n");
     do_check_true(request.nsIHttpChannel.requestSucceeded);
     do_check_eq(data, rangeBody.substring(1));
 
     // Try a server which doesn't support range requests
-    var chan = make_channel("http://localhost:4444/acceptranges");
+    var chan = make_channel(URL + "/acceptranges");
     chan.nsIResumableChannel.resumeAt(0, entityID);
     chan.nsIHttpChannel.setRequestHeader("X-Range-Type", "none", false);
     chan.asyncOpen(new ChannelListener(try_no_range, null, CL_EXPECT_FAILURE), null);
   }
 
   function try_no_range(request, data, ctx) {
     dump("*** try_no_range()\n");
     do_check_true(request.nsIHttpChannel.requestSucceeded);
     do_check_eq(request.status, NS_ERROR_NOT_RESUMABLE);
 
     // Try a server which supports "bytes" range requests
-    var chan = make_channel("http://localhost:4444/acceptranges");
+    var chan = make_channel(URL + "/acceptranges");
     chan.nsIResumableChannel.resumeAt(0, entityID);
     chan.nsIHttpChannel.setRequestHeader("X-Range-Type", "bytes", false);
     chan.asyncOpen(new ChannelListener(try_bytes_range, null), null);
   }
 
   function try_bytes_range(request, data, ctx) {
     dump("*** try_bytes_range()\n");
     do_check_true(request.nsIHttpChannel.requestSucceeded);
     do_check_eq(data, rangeBody);
 
     // Try a server which supports "foo" and "bar" range requests
-    var chan = make_channel("http://localhost:4444/acceptranges");
+    var chan = make_channel(URL + "/acceptranges");
     chan.nsIResumableChannel.resumeAt(0, entityID);
     chan.nsIHttpChannel.setRequestHeader("X-Range-Type", "foo, bar", false);
     chan.asyncOpen(new ChannelListener(try_foo_bar_range, null, CL_EXPECT_FAILURE), null);
   }
 
   function try_foo_bar_range(request, data, ctx) {
     dump("*** try_foo_bar_range()\n");
     do_check_true(request.nsIHttpChannel.requestSucceeded);
     do_check_eq(request.status, NS_ERROR_NOT_RESUMABLE);
 
     // Try a server which supports "foobar" range requests
-    var chan = make_channel("http://localhost:4444/acceptranges");
+    var chan = make_channel(URL + "/acceptranges");
     chan.nsIResumableChannel.resumeAt(0, entityID);
     chan.nsIHttpChannel.setRequestHeader("X-Range-Type", "foobar", false);
     chan.asyncOpen(new ChannelListener(try_foobar_range, null, CL_EXPECT_FAILURE), null);
   }
 
   function try_foobar_range(request, data, ctx) {
     dump("*** try_foobar_range()\n");
     do_check_true(request.nsIHttpChannel.requestSucceeded);
     do_check_eq(request.status, NS_ERROR_NOT_RESUMABLE);
 
     // Try a server which supports "bytes" and "foobar" range requests
-    var chan = make_channel("http://localhost:4444/acceptranges");
+    var chan = make_channel(URL + "/acceptranges");
     chan.nsIResumableChannel.resumeAt(0, entityID);
     chan.nsIHttpChannel.setRequestHeader("X-Range-Type", "bytes, foobar", false);
     chan.asyncOpen(new ChannelListener(try_bytes_foobar_range, null), null);
   }
 
   function try_bytes_foobar_range(request, data, ctx) {
     dump("*** try_bytes_foobar_range()\n");
     do_check_true(request.nsIHttpChannel.requestSucceeded);
     do_check_eq(data, rangeBody);
 
     // Try a server which supports "bytesfoo" and "bar" range requests
-    var chan = make_channel("http://localhost:4444/acceptranges");
+    var chan = make_channel(URL + "/acceptranges");
     chan.nsIResumableChannel.resumeAt(0, entityID);
     chan.nsIHttpChannel.setRequestHeader("X-Range-Type", "bytesfoo, bar", false);
     chan.asyncOpen(new ChannelListener(try_bytesfoo_bar_range, null, CL_EXPECT_FAILURE), null);
   }
 
   function try_bytesfoo_bar_range(request, data, ctx) {
     dump("*** try_bytesfoo_bar_range()\n");
     do_check_true(request.nsIHttpChannel.requestSucceeded);
     do_check_eq(request.status, NS_ERROR_NOT_RESUMABLE);
 
     // Try a server which doesn't send Accept-Ranges header at all
-    var chan = make_channel("http://localhost:4444/acceptranges");
+    var chan = make_channel(URL + "/acceptranges");
     chan.nsIResumableChannel.resumeAt(0, entityID);
     chan.asyncOpen(new ChannelListener(try_no_accept_ranges, null), null);
   }
 
   function try_no_accept_ranges(request, data, ctx) {
     dump("*** try_no_accept_ranges()\n");
     do_check_true(request.nsIHttpChannel.requestSucceeded);
     do_check_eq(data, rangeBody);
 
     // Try a successful suspend/resume from 0
-    var chan = make_channel("http://localhost:4444/range");
+    var chan = make_channel(URL + "/range");
     chan.nsIResumableChannel.resumeAt(0, entityID);
     chan.asyncOpen(new ChannelListener(try_suspend_resume, null,
                                        CL_SUSPEND | CL_EXPECT_3S_DELAY), null);
   }
 
   function try_suspend_resume(request, data, ctx) {
     dump("*** try_suspend_resume()\n");
     do_check_true(request.nsIHttpChannel.requestSucceeded);
     do_check_eq(data, rangeBody);
 
     // Try a successful resume from 0
-    var chan = make_channel("http://localhost:4444/range");
+    var chan = make_channel(URL + "/range");
     chan.nsIResumableChannel.resumeAt(0, entityID);
     chan.asyncOpen(new ChannelListener(success, null), null);
   }
 
   function success(request, data, ctx) {
     dump("*** success()\n");
     do_check_true(request.nsIHttpChannel.requestSucceeded);
     do_check_eq(data, rangeBody);
 
 
     // Authentication (no password; working resume)
     // (should not give us any data)
-    var chan = make_channel("http://localhost:4444/range");
+    var chan = make_channel(URL + "/range");
     chan.nsIResumableChannel.resumeAt(1, entityID);
     chan.nsIHttpChannel.setRequestHeader("X-Need-Auth", "true", false);
     chan.asyncOpen(new ChannelListener(test_auth_nopw, null, CL_EXPECT_FAILURE), null);
   }
 
   function test_auth_nopw(request, data, ctx) {
     dump("*** test_auth_nopw()\n");
     do_check_false(request.nsIHttpChannel.requestSucceeded);
     do_check_eq(request.status, NS_ERROR_ENTITY_CHANGED);
 
     // Authentication + not working resume
-    var chan = make_channel("http://guest:guest@localhost:4444/auth");
+    var chan = make_channel("http://guest:guest@localhost:" +
+                            httpserver.identity.primaryPort + "/auth");
     chan.nsIResumableChannel.resumeAt(1, entityID);
     chan.notificationCallbacks = new Requestor();
     chan.asyncOpen(new ChannelListener(test_auth, null, CL_EXPECT_FAILURE), null);
   }
   function test_auth(request, data, ctx) {
     dump("*** test_auth()\n");
     do_check_eq(request.status, NS_ERROR_NOT_RESUMABLE);
     do_check_true(request.nsIHttpChannel.responseStatus < 300);
 
     // Authentication + working resume
-    var chan = make_channel("http://guest:guest@localhost:4444/range");
+    var chan = make_channel("http://guest:guest@localhost:" +
+                            httpserver.identity.primaryPort + "/range");
     chan.nsIResumableChannel.resumeAt(1, entityID);
     chan.notificationCallbacks = new Requestor();
     chan.nsIHttpChannel.setRequestHeader("X-Need-Auth", "true", false);
     chan.asyncOpen(new ChannelListener(test_auth_resume, null), null);
   }
 
   function test_auth_resume(request, data, ctx) {
     dump("*** test_auth_resume()\n");
     do_check_eq(data, rangeBody.substring(1));
     do_check_true(request.nsIHttpChannel.requestSucceeded);
 
     // 404 page (same content length as real content)
-    var chan = make_channel("http://localhost:4444/range");
+    var chan = make_channel(URL + "/range");
     chan.nsIResumableChannel.resumeAt(1, entityID);
     chan.nsIHttpChannel.setRequestHeader("X-Want-404", "true", false);
     chan.asyncOpen(new ChannelListener(test_404, null, CL_EXPECT_FAILURE), null);
   }
 
   function test_404(request, data, ctx) {
     dump("*** test_404()\n");
     do_check_eq(request.status, NS_ERROR_ENTITY_CHANGED);
     do_check_eq(request.nsIHttpChannel.responseStatus, 404);
 
     // 416 Requested Range Not Satisfiable
-    var chan = make_channel("http://localhost:4444/range");
+    var chan = make_channel(URL + "/range");
     chan.nsIResumableChannel.resumeAt(1000, entityID);
     chan.asyncOpen(new ChannelListener(test_416, null, CL_EXPECT_FAILURE), null);
   }
 
   function test_416(request, data, ctx) {
     dump("*** test_416()\n");
     do_check_eq(request.status, NS_ERROR_ENTITY_CHANGED);
     do_check_eq(request.nsIHttpChannel.responseStatus, 416);
 
     // Redirect + successful resume
-    var chan = make_channel("http://localhost:4444/redir");
-    chan.nsIHttpChannel.setRequestHeader("X-Redir-To", "http://localhost:4444/range", false);
+    var chan = make_channel(URL + "/redir");
+    chan.nsIHttpChannel.setRequestHeader("X-Redir-To", URL + "/range", false);
     chan.nsIResumableChannel.resumeAt(1, entityID);
     chan.asyncOpen(new ChannelListener(test_redir_resume, null), null);
   }
 
   function test_redir_resume(request, data, ctx) {
     dump("*** test_redir_resume()\n");
     do_check_true(request.nsIHttpChannel.requestSucceeded);
     do_check_eq(data, rangeBody.substring(1));
     do_check_eq(request.nsIHttpChannel.responseStatus, 206);
 
     // Redirect + failed resume
-    var chan = make_channel("http://localhost:4444/redir");
-    chan.nsIHttpChannel.setRequestHeader("X-Redir-To", "http://localhost:4444/", false);
+    var chan = make_channel(URL + "/redir");
+    chan.nsIHttpChannel.setRequestHeader("X-Redir-To", URL + "/", false);
     chan.nsIResumableChannel.resumeAt(1, entityID);
     chan.asyncOpen(new ChannelListener(test_redir_noresume, null, CL_EXPECT_FAILURE), null);
   }
 
   function test_redir_noresume(request, data, ctx) {
     dump("*** test_redir_noresume()\n");
     do_check_eq(request.status, NS_ERROR_NOT_RESUMABLE);
 
     httpserver.stop(do_test_finished);
   }
 
-  httpserver.start(4444);
-  var chan = make_channel("http://localhost:4444/range");
+  httpserver.start(-1);
+  var chan = make_channel(URL + "/range");
   chan.asyncOpen(new ChannelListener(get_entity_id, null), null);
   do_test_pending();
 }
 
 // HANDLERS
 
 function handleAuth(metadata, response) {
   // btoa("guest:guest"), but that function is not available here
diff --git a/netwerk/test/unit/test_resumable_truncate.js b/netwerk/test/unit/test_resumable_truncate.js
--- a/netwerk/test/unit/test_resumable_truncate.js
+++ b/netwerk/test/unit/test_resumable_truncate.js
@@ -66,26 +66,29 @@ Canceler.prototype = {
   }
 };
 
 function finish_test() {
   httpserver.stop(do_test_finished);
 }
 
 function start_cache_read() {
-  var chan = make_channel("http://localhost:4444/cached/test.gz");
+  var chan = make_channel("http://localhost:" +
+                          httpserver.identity.primaryPort + "/cached/test.gz");
   chan.asyncOpen(new ChannelListener(finish_test, null), null);
 }
 
 function start_canceler() {
-  var chan = make_channel("http://localhost:4444/cached/test.gz");
+  var chan = make_channel("http://localhost:" +
+                          httpserver.identity.primaryPort + "/cached/test.gz");
   chan.asyncOpen(new Canceler(start_cache_read), null);
 }
 
 function run_test() {
   httpserver = new HttpServer();
   httpserver.registerPathHandler("/cached/test.gz", cachedHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
-  var chan = make_channel("http://localhost:4444/cached/test.gz");
+  var chan = make_channel("http://localhost:" +
+                          httpserver.identity.primaryPort + "/cached/test.gz");
   chan.asyncOpen(new ChannelListener(start_canceler, null), null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_simple.js b/netwerk/test/unit/test_simple.js
--- a/netwerk/test/unit/test_simple.js
+++ b/netwerk/test/unit/test_simple.js
@@ -21,27 +21,28 @@ if (dbg) { print("============== START =
 function run_test() {
   setup_test();
   do_test_pending();
 }
 
 function setup_test() {
   if (dbg) { print("============== setup_test: in"); }
   httpserver.registerPathHandler(testpath, serverHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
   var channel = setupChannel(testpath);
   // ChannelListener defined in head_channels.js
   channel.asyncOpen(new ChannelListener(checkRequest, channel), null);
   if (dbg) { print("============== setup_test: out"); }
 }
 
 function setupChannel(path) {
   var ios = Cc["@mozilla.org/network/io-service;1"].
                        getService(Ci.nsIIOService);
-  var chan = ios.newChannel("http://localhost:4444" + path, "", null);
+  var chan = ios.newChannel("http://localhost:" +
+                            httpserver.identity.primaryPort + path, "", null);
   chan.QueryInterface(Ci.nsIHttpChannel);
   chan.requestMethod = "GET";
   return chan;
 }
 
 function serverHandler(metadata, response) {
   if (dbg) { print("============== serverHandler: in"); }
   response.setHeader("Content-Type", "text/plain", false);
diff --git a/netwerk/test/unit/test_speculative_connect.js b/netwerk/test/unit/test_speculative_connect.js
--- a/netwerk/test/unit/test_speculative_connect.js
+++ b/netwerk/test/unit/test_speculative_connect.js
@@ -4,17 +4,17 @@ const CC = Components.Constructor;
 
 const ServerSocket = CC("@mozilla.org/network/server-socket;1",
                         "nsIServerSocket",
                         "init");
 
 var serv;
 
 function TestServer() {
-    this.listener = ServerSocket(4444, true, -1);
+    this.listener = ServerSocket(-1, true, -1);
     this.listener.asyncListen(this);
 }
 
 TestServer.prototype = {
     QueryInterface: function(iid) {
         if (iid.equals(Ci.nsIServerSocket) ||
             iid.equals(Ci.nsISupports))
             return this;
@@ -29,14 +29,14 @@ TestServer.prototype = {
     onStopListening: function(socket) {}
 }
 
 function run_test() {
     var ios = Cc["@mozilla.org/network/io-service;1"]
         .getService(Ci.nsIIOService);    
 
     serv = new TestServer();
-    URI = ios.newURI("http://localhost:4444/just/a/test", null, null);
+    URI = ios.newURI("http://localhost:" + serv.listener.port + "/just/a/test", null, null);
     ios.QueryInterface(Components.interfaces.nsISpeculativeConnect)
         .speculativeConnect(URI, null);
     do_test_pending();
 }
 
diff --git a/netwerk/test/unit/test_traceable_channel.js b/netwerk/test/unit/test_traceable_channel.js
--- a/netwerk/test/unit/test_traceable_channel.js
+++ b/netwerk/test/unit/test_traceable_channel.js
@@ -5,17 +5,20 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 const Cr = Components.results;
 
 Cu.import("resource://testing-common/httpd.js");
 
-var httpserver = null;
+var httpserver = new HttpServer();
+httpserver.start(-1);
+const PORT = httpserver.identity.primaryPort;
+
 var pipe = null;
 var streamSink = null;
 
 var originalBody = "original http response body";
 var gotOnStartRequest = false;
 
 function TracingListener() {}
 
@@ -26,19 +29,19 @@ TracingListener.prototype = {
     gotOnStartRequest = true;
 
     request.QueryInterface(Components.interfaces.nsIHttpChannelInternal);
 
 // local/remote addresses broken in e10s: disable for now
 /*
     do_check_eq(request.localAddress, "127.0.0.1");
     do_check_eq(request.localPort > 0, true);
-    do_check_neq(request.localPort, 4444);
+    do_check_neq(request.localPort, PORT);
     do_check_eq(request.remoteAddress, "127.0.0.1");
-    do_check_eq(request.remotePort, 4444);
+    do_check_eq(request.remotePort, PORT);
 */
 
     // Make sure listener can't be replaced after OnStartRequest was called.
     request.QueryInterface(Components.interfaces.nsITraceableChannel);
     try {
       var newListener = new TracingListener();
       newListener.listener = request.setNewListener(newListener);
     } catch(e) {
@@ -142,16 +145,14 @@ function make_channel(url) {
 function channel_finished(request, input, ctx) {
   httpserver.stop(do_test_finished);
 }
 
 function run_test() {
   var observer = new HttpResponseExaminer();
   observer.register();
 
-  httpserver = new HttpServer();
   httpserver.registerPathHandler("/testdir", test_handler);
-  httpserver.start(4444);
 
-  var channel = make_channel("http://localhost:4444/testdir");
+  var channel = make_channel("http://localhost:" + PORT + "/testdir");
   channel.asyncOpen(new ChannelListener(channel_finished), null);
   do_test_pending();
 }
diff --git a/netwerk/test/unit/test_xmlhttprequest.js b/netwerk/test/unit/test_xmlhttprequest.js
--- a/netwerk/test/unit/test_xmlhttprequest.js
+++ b/netwerk/test/unit/test_xmlhttprequest.js
@@ -8,17 +8,18 @@ Cu.import("resource://testing-common/htt
 var httpserver = new HttpServer();
 var testpath = "/simple";
 var httpbody = "<?xml version='1.0' ?><root>0123456789</root>";
 
 function createXHR(async)
 {
   var xhr = Cc["@mozilla.org/xmlextras/xmlhttprequest;1"]
             .createInstance(Ci.nsIXMLHttpRequest);
-  xhr.open("GET", "http://localhost:4444" + testpath, async);
+  xhr.open("GET", "http://localhost:" +
+           httpserver.identity.primaryPort + testpath, async);
   return xhr;
 }
 
 function checkResults(xhr)
 {
   if (xhr.readyState != 4)
     return false;
 
@@ -28,17 +29,17 @@ function checkResults(xhr)
   var root_node = xhr.responseXML.getElementsByTagName('root').item(0);
   do_check_eq(root_node.firstChild.data, "0123456789");
   return true;
 }
 
 function run_test()
 {
   httpserver.registerPathHandler(testpath, serverHandler);
-  httpserver.start(4444);
+  httpserver.start(-1);
 
   // Test sync XHR sending
   var sync = createXHR(false);
   sync.send(null);
   checkResults(sync);
 
   // Test async XHR sending
   let async = createXHR(true);
diff --git a/netwerk/test/unit/xpcshell.ini b/netwerk/test/unit/xpcshell.ini
--- a/netwerk/test/unit/xpcshell.ini
+++ b/netwerk/test/unit/xpcshell.ini
@@ -180,14 +180,16 @@ run-if = hasNode
 [test_standardurl_port.js]
 [test_streamcopier.js]
 [test_traceable_channel.js]
 [test_unescapestring.js]
 [test_xmlhttprequest.js]
 [test_XHR_redirects.js]
 [test_pinned_app_cache.js]
 [test_offlinecache_custom-directory.js]
+run-sequentially = Hardcoded hash value includes port 4444.
 [test_bug767025.js]
+run-sequentially = Hardcoded hash value includes port 4444.
 [test_bug826063.js]
 [test_bug812167.js]
 [test_tldservice_nextsubdomain.js]
 [test_about_protocol.js]
 [test_bug856978.js]
diff --git a/netwerk/test/unit_ipc/head_channels_clone.js b/netwerk/test/unit_ipc/head_channels_clone.js
--- a/netwerk/test/unit_ipc/head_channels_clone.js
+++ b/netwerk/test/unit_ipc/head_channels_clone.js
@@ -1,6 +1,8 @@
 //
 // Load standard base class for network tests into child process
 //
 
+Components.utils.import('resource://gre/modules/XPCOMUtils.jsm');
+
 load("../unit/head_channels.js");
 
