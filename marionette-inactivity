# HG changeset patch
# Parent ce881259e2d0a10897c9ca1ecf116a1cba1a8e56
# User Mihnea Dobrescu-Balaur <mihneadb@gmail.com>
Bug 904232 - Add inactivity timeout for marionette tests,r=jgriffin

diff --git a/testing/marionette/client/marionette/marionette.py b/testing/marionette/client/marionette/marionette.py
--- a/testing/marionette/client/marionette/marionette.py
+++ b/testing/marionette/client/marionette/marionette.py
@@ -908,33 +908,38 @@ class Marionette(object):
                     unwrapped = HTMLElement(self, value[key])
                 else:
                     unwrapped[key] = self.unwrapValue(value[key])
         else:
             unwrapped = value
 
         return unwrapped
 
-    def execute_js_script(self, script, script_args=None, async=True, new_sandbox=True, special_powers=False, script_timeout=None, filename=None):
+    def execute_js_script(self, script, script_args=None, async=True,
+                          new_sandbox=True, special_powers=False,
+                          script_timeout=None, inactivity_timeout=None,
+                          filename=None):
         if script_args is None:
             script_args = []
         args = self.wrapArguments(script_args)
         response = self._send_message('executeJSScript',
                                       'value',
                                       value=script,
                                       args=args,
                                       async=async,
                                       newSandbox=new_sandbox,
                                       specialPowers=special_powers,
                                       scriptTimeout=script_timeout,
+                                      inactivityTimeout=inactivity_timeout,
                                       filename=filename,
                                       line=None)
         return self.unwrapValue(response)
 
-    def execute_script(self, script, script_args=None, new_sandbox=True, special_powers=False, script_timeout=None):
+    def execute_script(self, script, script_args=None, new_sandbox=True,
+                       special_powers=False, script_timeout=None):
         '''
         Executes a synchronous JavaScript script, and returns the result (or None if the script does return a value).
 
         The script is executed in the context set by the most recent
         set_context() call, or to the CONTEXT_CONTENT context if set_context()
         has not been called.
 
         :param script: A string containing the JavaScript to execute.
diff --git a/testing/marionette/client/marionette/marionette_test.py b/testing/marionette/client/marionette/marionette_test.py
--- a/testing/marionette/client/marionette/marionette_test.py
+++ b/testing/marionette/client/marionette/marionette_test.py
@@ -334,16 +334,17 @@ class MarionetteTestCase(CommonTestCase)
             time.sleep(0.5)
         else:
             raise TimeoutException("wait_for_condition timed out")
 
 class MarionetteJSTestCase(CommonTestCase):
 
     context_re = re.compile(r"MARIONETTE_CONTEXT(\s*)=(\s*)['|\"](.*?)['|\"];")
     timeout_re = re.compile(r"MARIONETTE_TIMEOUT(\s*)=(\s*)(\d+);")
+    inactivity_timeout_re = re.compile(r"MARIONETTE_INACTIVITY_TIMEOUT(\s*)=(\s*)(\d+);")
     match_re = re.compile(r"test_(.*)\.js$")
 
     def __init__(self, marionette_weakref, methodName='runTest', jsFile=None):
         assert(jsFile)
         self.jsFile = jsFile
         self._marionette_weakref = marionette_weakref
         self.marionette = None
         CommonTestCase.__init__(self, methodName)
@@ -383,20 +384,25 @@ class MarionetteJSTestCase(CommonTestCas
         if context != "chrome":
             self.marionette.navigate('data:text/html,<html>test page</html>')
 
         timeout = self.timeout_re.search(js)
         if timeout:
             timeout = timeout.group(3)
             self.marionette.set_script_timeout(timeout)
 
+        inactivity_timeout = self.inactivity_timeout_re.search(js)
+        if inactivity_timeout:
+            inactivity_timeout = inactivity_timeout.group(3)
+
         try:
             results = self.marionette.execute_js_script(js,
                                                         args,
                                                         special_powers=True,
+                                                        inactivity_timeout=inactivity_timeout,
                                                         filename=os.path.basename(self.jsFile))
 
             self.assertTrue(not 'timeout' in self.jsFile,
                             'expected timeout not triggered')
 
             if 'fail' in self.jsFile:
                 self.assertTrue(results['failed'] > 0,
                                 "expected test failures didn't occur")
diff --git a/testing/marionette/marionette-listener.js b/testing/marionette/marionette-listener.js
--- a/testing/marionette/marionette-listener.js
+++ b/testing/marionette/marionette-listener.js
@@ -47,16 +47,20 @@ let sandbox;
 
 // the unload handler
 let onunload;
 
 // Flag to indicate whether an async script is currently running or not.
 let asyncTestRunning = false;
 let asyncTestCommandId;
 let asyncTestTimeoutId;
+
+let inactivityTimeoutId = null;
+let heartbeatCallback = function () {}; // Called by the simpletest methods.
+
 let originalOnError;
 //timer for doc changes
 let checkTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
 // Send move events about this often
 let EVENT_INTERVAL = 30; // milliseconds
 // For assigning unique ids to all touches
 let nextTouchId = 1000;
 //Keep track of active Touches
@@ -328,18 +332,19 @@ function createExecuteContentSandbox(aWi
   sandbox.global = sandbox;
   sandbox.window = aWindow;
   sandbox.document = sandbox.window.document;
   sandbox.navigator = sandbox.window.navigator;
   sandbox.testUtils = utils;
   sandbox.asyncTestCommandId = asyncTestCommandId;
 
   let marionette = new Marionette(this, aWindow, "content",
-                                  marionetteLogObj,
-                                  timeout, marionetteTestName);
+                                  marionetteLogObj, timeout,
+                                  heartbeatCallback,
+                                  marionetteTestName);
   sandbox.marionette = marionette;
   marionette.exports.forEach(function(fn) {
     try {
       sandbox[fn] = marionette[fn].bind(marionette);
     }
     catch(e) {
       sandbox[fn] = marionette[fn];
     }
@@ -349,16 +354,20 @@ function createExecuteContentSandbox(aWi
     return new SpecialPowers(aWindow);
   });
 
   sandbox.asyncComplete = function sandbox_asyncComplete(value, status, stack, commandId) {
     if (commandId == asyncTestCommandId) {
       curFrame.removeEventListener("unload", onunload, false);
       curFrame.clearTimeout(asyncTestTimeoutId);
 
+      if (inactivityTimeoutId != null) {
+        curFrame.clearTimeout(inactivityTimeoutId);
+      }
+
       sendSyncMessage("Marionette:shareData",
                       {log: elementManager.wrapValue(marionetteLogObj.getLogs())});
       marionetteLogObj.clearLogs();
 
       if (status == 0){
         if (Object.keys(_emu_cbs).length) {
           _emu_cbs = {};
           sendError("Emulator callback still pending when finish() called",
@@ -371,16 +380,17 @@ function createExecuteContentSandbox(aWi
       }
       else {
         sendError(value, status, stack, commandId);
       }
 
       asyncTestRunning = false;
       asyncTestTimeoutId = undefined;
       asyncTestCommandId = undefined;
+      inactivityTimeoutId = null;
     }
   };
   sandbox.finish = function sandbox_finish() {
     if (asyncTestRunning) {
       sandbox.asyncComplete(marionette.generate_results(), 0, null, sandbox.asyncTestCommandId);
     } else {
       return marionette.generate_results();
     }
@@ -392,16 +402,31 @@ function createExecuteContentSandbox(aWi
   return sandbox;
 }
 
 /**
  * Execute the given script either as a function body (executeScript)
  * or directly (for 'mochitest' like JS Marionette tests)
  */
 function executeScript(msg, directInject) {
+  // Set up inactivity timeout.
+  if (msg.json.inactivityTimeout) {
+    let setTimer = function() {
+        inactivityTimeoutId = curFrame.setTimeout(function() {
+        sendError('timed out due to inactivity', 28, null, asyncTestCommandId);
+      }, msg.json.inactivityTimeout);
+   };
+
+    setTimer();
+    heartbeatCallback = function resetInactivityTimeout() {
+      curFrame.clearTimeout(inactivityTimeoutId);
+      setTimer();
+    };
+  }
+
   asyncTestCommandId = msg.json.command_id;
   let script = msg.json.value;
 
   if (msg.json.newSandbox || !sandbox) {
     sandbox = createExecuteContentSandbox(curFrame,
                                           msg.json.timeout);
     if (!sandbox) {
       sendError("Could not create sandbox!", 500, null, asyncTestCommandId);
@@ -501,27 +526,43 @@ function executeJSScript(msg) {
  * This function is used by executeAsync and executeJSScript to execute a script
  * in a sandbox. 
  * 
  * For executeJSScript, it will return a message only when the finish() method is called.
  * For executeAsync, it will return a response when marionetteScriptFinished/arguments[arguments.length-1] 
  * method is called, or if it times out.
  */
 function executeWithCallback(msg, useFinish) {
+  // Set up inactivity timeout.
+  if (msg.json.inactivityTimeout) {
+    let setTimer = function() {
+        inactivityTimeoutId = curFrame.setTimeout(function() {
+        sandbox.asyncComplete('timed out due to inactivity', 28, null, asyncTestCommandId);
+      }, msg.json.inactivityTimeout);
+   };
+
+    setTimer();
+    heartbeatCallback = function resetInactivityTimeout() {
+      curFrame.clearTimeout(inactivityTimeoutId);
+      setTimer();
+    };
+  }
+
   let script = msg.json.value;
   asyncTestCommandId = msg.json.command_id;
 
   onunload = function() {
     sendError("unload was called", 17, null, asyncTestCommandId);
   };
   curFrame.addEventListener("unload", onunload, false);
 
   if (msg.json.newSandbox || !sandbox) {
     sandbox = createExecuteContentSandbox(curFrame,
-                                          msg.json.timeout);
+                                          msg.json.timeout,
+                                          heartbeatCallback);
     if (!sandbox) {
       sendError("Could not create sandbox!", 17, null, asyncTestCommandId);
       return;
     }
   }
   else {
     sandbox.asyncTestCommandId = asyncTestCommandId;
   }
diff --git a/testing/marionette/marionette-server.js b/testing/marionette/marionette-server.js
--- a/testing/marionette/marionette-server.js
+++ b/testing/marionette/marionette-server.js
@@ -123,16 +123,18 @@ function MarionetteServerConnection(aPre
   this.messageManager = this.globalMessageManager;
   this.browsers = {}; //holds list of BrowserObjs
   this.curBrowser = null; // points to current browser
   this.context = "content";
   this.scriptTimeout = null;
   this.searchTimeout = null;
   this.pageTimeout = null;
   this.timer = null;
+  this.inactivityTimer = null;
+  this.heartbeatCallback = function () {}; // called by simpletest methods
   this.marionetteLog = new MarionetteLogObj();
   this.command_id = null;
   this.mainFrame = null; //topmost chrome frame
   this.curFrame = null; // chrome iframe that currently has focus
   this.importedScripts = FileUtils.getFile('TmpD', ['marionettescriptchrome']);
   this.currentFrameElement = null;
   this.testName = null;
   this.mozBrowserClose = null;
@@ -706,16 +708,17 @@ MarionetteServerConnection.prototype = {
    * @param object aRequest
    *        'value' member is the script to run
    *        'args' member holds the arguments to the script
    * @param boolean directInject
    *        if true, it will be run directly and not as a 
    *        function body
    */
   execute: function MDA_execute(aRequest, directInject) {
+    let inactivityTimeout = aRequest.inactivityTimeout;
     let timeout = aRequest.scriptTimeout ? aRequest.scriptTimeout : this.scriptTimeout;
     let command_id = this.command_id = this.getCommandId();
     let script;
     this.logRequest("execute", aRequest);
     if (aRequest.newSandbox == undefined) {
       //if client does not send a value in newSandbox, 
       //then they expect the same behaviour as webdriver
       aRequest.newSandbox = true;
@@ -730,30 +733,56 @@ MarionetteServerConnection.prototype = {
                        specialPowers: aRequest.specialPowers,
                        filename: aRequest.filename,
                        line: aRequest.line
                      },
                      command_id);
       return;
     }
 
+    // handle the inactivity timeout
+    let that = this;
+    if (inactivityTimeout) {
+     let inactivityTimeoutHandler = function(message, status) {
+      let error_msg = {message: value, status: status};
+      that.sendToClient({from: that.actorID, error: error_msg},
+                        marionette.command_id);
+     };
+     let setTimer = function() {
+      that.inactivityTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+      if (that.inactivityTimer != null) {
+       that.inactivityTimer.initWithCallback(function() {
+        inactivityTimeoutHandler("timed out due to inactivity", 28);
+       }, inactivityTimeout, Ci.nsITimer.TYPE_ONESHOT);
+      }
+     }
+     setTimer();
+     this.heartbeatCallback = function resetInactivityTimer() {
+      that.inactivityTimer.cancel();
+      setTimer();
+     }
+    }
+
     let curWindow = this.getCurrentWindow();
     let marionette = new Marionette(this, curWindow, "chrome",
                                     this.marionetteLog,
-                                    timeout, this.testName);
+                                    timeout, this.heartbeatCallback, this.testName);
     let _chromeSandbox = this.createExecuteSandbox(curWindow,
                                                    marionette,
                                                    aRequest.args,
                                                    aRequest.specialPowers,
                                                    command_id);
     if (!_chromeSandbox)
       return;
 
     try {
       _chromeSandbox.finish = function chromeSandbox_finish() {
+        if (that.inactivityTimer != null) {
+          that.inactivityTimer.cancel();
+        }
         return marionette.generate_results();
       };
 
       if (directInject) {
         script = aRequest.value;
       }
       else {
         script = "let func = function() {" +
@@ -798,16 +827,17 @@ MarionetteServerConnection.prototype = {
    * @param object aRequest
    *        'value' member holds the script to execute
    *        'args' member holds the arguments to the script
    *        'timeout' member will be used as the script timeout if it is given
    */
   executeJSScript: function MDA_executeJSScript(aRequest) {
     let timeout = aRequest.scriptTimeout ? aRequest.scriptTimeout : this.scriptTimeout;
     let command_id = this.command_id = this.getCommandId();
+
     //all pure JS scripts will need to call Marionette.finish() to complete the test.
     if (aRequest.newSandbox == undefined) {
       //if client does not send a value in newSandbox, 
       //then they expect the same behaviour as webdriver
       aRequest.newSandbox = true;
     }
     if (this.context == "chrome") {
       if (aRequest.async) {
@@ -820,16 +850,17 @@ MarionetteServerConnection.prototype = {
     else {
       this.sendAsync("executeJSScript",
                      {
                        value: aRequest.value,
                        args: aRequest.args,
                        newSandbox: aRequest.newSandbox,
                        async: aRequest.async,
                        timeout: timeout,
+                       inactivityTimeout: aRequest.inactivityTimeout,
                        specialPowers: aRequest.specialPowers,
                        filename: aRequest.filename,
                        line: aRequest.line,
                      },
                      command_id);
    }
   },
 
@@ -844,16 +875,17 @@ MarionetteServerConnection.prototype = {
    * @param object aRequest
    *        'value' member holds the script to execute
    *        'args' member holds the arguments for the script
    * @param boolean directInject
    *        if true, it will be run directly and not as a 
    *        function body
    */
   executeWithCallback: function MDA_executeWithCallback(aRequest, directInject) {
+    let inactivityTimeout = aRequest.inactivityTimeout;
     let timeout = aRequest.scriptTimeout ? aRequest.scriptTimeout : this.scriptTimeout;
     let command_id = this.command_id = this.getCommandId();
     let script;
     this.logRequest("executeWithCallback", aRequest);
     if (aRequest.newSandbox == undefined) {
       //if client does not send a value in newSandbox, 
       //then they expect the same behaviour as webdriver
       aRequest.newSandbox = true;
@@ -862,31 +894,52 @@ MarionetteServerConnection.prototype = {
     if (this.context == "content") {
       this.sendAsync("executeAsyncScript",
                      {
                        value: aRequest.value,
                        args: aRequest.args,
                        id: this.command_id,
                        newSandbox: aRequest.newSandbox,
                        timeout: timeout,
+                       inactivityTimeout: inactivityTimeout,
                        specialPowers: aRequest.specialPowers,
                        filename: aRequest.filename,
                        line: aRequest.line
                      },
                      command_id);
       return;
     }
 
+    // handle the inactivity timeout
+    if (inactivityTimeout) {
+     this.inactivityTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+     if (this.inactivityTimer != null) {
+      this.inactivityTimer.initWithCallback(function() {
+       chromeAsyncReturnFunc("timed out due to inactivity", 28);
+      }, inactivityTimeout, Ci.nsITimer.TYPE_ONESHOT);
+     }
+     let that = this;
+     this.heartbeatCallback = function resetInactivityTimer() {
+      that.inactivityTimer.cancel();
+      that.inactivityTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+      if (that.inactivityTimer != null) {
+       that.inactivityTimer.initWithCallback(function() {
+        chromeAsyncReturnFunc("timed out due to inactivity", 28);
+       }, inactivityTimeout, Ci.nsITimer.TYPE_ONESHOT);
+      }
+     }
+    }
+
     let curWindow = this.getCurrentWindow();
     let original_onerror = curWindow.onerror;
     let that = this;
     that.timeout = timeout;
     let marionette = new Marionette(this, curWindow, "chrome",
                                     this.marionetteLog,
-                                    timeout, this.testName);
+                                    timeout, this.heartbeatCallback, this.testName);
     marionette.command_id = this.command_id;
 
     function chromeAsyncReturnFunc(value, status, stacktrace) {
       if (that._emu_cbs && Object.keys(that._emu_cbs).length) {
         value = "Emulator callback still pending when finish() called";
         status = 500;
         that._emu_cbs = null;
       }
@@ -906,16 +959,19 @@ MarionetteServerConnection.prototype = {
                             marionette.command_id);
         }
         else {
           let error_msg = {message: value, status: status, stacktrace: stacktrace};
           that.sendToClient({from: that.actorID, error: error_msg},
                             marionette.command_id);
         }
       }
+      if (that.inactivityTimer != null) {
+        that.inactivityTimer.cancel();
+      }
     }
 
     curWindow.onerror = function (errorMsg, url, lineNumber) {
       chromeAsyncReturnFunc(errorMsg + " at: " + url + " line: " + lineNumber, 17);
       return true;
     };
 
     function chromeAsyncFinish() {
diff --git a/testing/marionette/marionette-simpletest.js b/testing/marionette/marionette-simpletest.js
--- a/testing/marionette/marionette-simpletest.js
+++ b/testing/marionette/marionette-simpletest.js
@@ -1,72 +1,80 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 /*
  * The Marionette object, passed to the script context.
  */
 
-this.Marionette = function Marionette(scope, window, context, logObj, timeout, testName) {
+this.Marionette = function Marionette(scope, window, context, logObj, timeout,
+                                      heartbeatCallback, testName) {
   this.scope = scope;
   this.window = window;
   this.tests = [];
   this.logObj = logObj;
   this.context = context;
   this.timeout = timeout;
+  this.heartbeatCallback = heartbeatCallback;
   this.testName = testName;
   this.TEST_UNEXPECTED_FAIL = "TEST-UNEXPECTED-FAIL";
   this.TEST_PASS = "TEST-PASS";
   this.TEST_KNOWN_FAIL = "TEST-KNOWN-FAIL";
 }
 
 Marionette.prototype = {
   exports: ['ok', 'is', 'isnot', 'log', 'getLogs', 'generate_results', 'waitFor',
             'runEmulatorCmd', 'TEST_PASS', 'TEST_KNOWN_FAIL',
             'TEST_UNEXPECTED_FAIL'],
 
   ok: function Marionette__ok(condition, name, passString, failString, diag) {
+    this.heartbeatCallback();
     if (typeof(diag) == "undefined") {
       diag = this.repr(condition) + " was " + !!condition + ", expected true";
     }
     let test = {'result': !!condition, 'name': name, 'diag': diag};
     this.logResult(test,
                    typeof(passString) == "undefined" ? this.TEST_PASS : passString,
                    typeof(failString) == "undefined" ? this.TEST_UNEXPECTED_FAIL : failString);
     this.tests.push(test);
   },
 
   is: function Marionette__is(a, b, name, passString, failString) {
+    this.heartbeatCallback();
     let pass = (a == b);
     let diag = pass ? this.repr(a) + " should equal " + this.repr(b)
                     : "got " + this.repr(a) + ", expected " + this.repr(b);
     this.ok(pass, name, passString, failString, diag);
   },
 
   isnot: function Marionette__isnot (a, b, name, passString, failString) {
+    this.heartbeatCallback();
     let pass = (a != b);
     let diag = pass ? this.repr(a) + " should not equal " + this.repr(b)
                     : "didn't expect " + this.repr(a) + ", but got it";
     this.ok(pass, name, passString, failString, diag);
   },
 
   log: function Marionette__log(msg, level) {
+    this.heartbeatCallback();
     dump("MARIONETTE LOG: " + (level ? level : "INFO") + ": " + msg + "\n");
     if (this.logObj != null) {
       this.logObj.log(msg, level);
     }
   },
 
   getLogs: function Marionette__getLogs() {
+    this.heartbeatCallback();
     if (this.logObj != null) {
       this.logObj.getLogs();
     }
   },
 
   generate_results: function Marionette__generate_results() {
+    this.heartbeatCallback();
     let passed = 0;
     let failed = 0;
     let failures = [];
     for (let i in this.tests) {
       if(this.tests[i].result) {
         passed++;
       }
       else {
@@ -76,20 +84,22 @@ Marionette.prototype = {
       }
     }
     // Reset state in case this object is reused for more tests.
     this.tests = [];
     return {"passed": passed, "failed": failed, "failures": failures};
   },
 
   logToFile: function Marionette__logToFile(file) {
+    this.heartbeatCallback();
     //TODO
   },
 
   logResult: function Marionette__logResult(test, passString, failString) {
+    this.heartbeatCallback();
     //TODO: dump to file
     let resultString = test.result ? passString : failString;
     let diagnostic = test.name + (test.diag ? " - " + test.diag : "");
     let msg = resultString + " | " + this.testName + " | " + diagnostic;
     dump("MARIONETTE TEST RESULT:" + msg + "\n");
   },
 
   repr: function Marionette__repr(o) {
@@ -127,29 +137,31 @@ Marionette.prototype = {
           if (idx != -1) {
               o = o.substr(0, idx) + "{...}";
           }
       }
       return ostring;
   },
 
   waitFor: function test_waitFor(callback, test, timeout) {
+      this.heartbeatCallback();
       if (test()) {
           callback();
           return;
       }
       var now = Date.now();
       var deadline = now + (typeof(timeout) == "undefined" ? this.timeout : timeout);
       if (deadline <= now) {
         dump("waitFor timeout: " + test.toString() + "\n");
         // the script will timeout here, so no need to raise a separate
         // timeout exception
         return;
       }
       this.window.setTimeout(this.waitFor.bind(this), 100, callback, test, deadline - now);
   },
 
   runEmulatorCmd: function runEmulatorCmd(cmd, callback) {
+    this.heartbeatCallback();
     this.scope.runEmulatorCmd(cmd, callback);
   },
 
 };
 
