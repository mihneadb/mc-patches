# HG changeset patch
# Parent ce881259e2d0a10897c9ca1ecf116a1cba1a8e56
# User Mihnea Dobrescu-Balaur <mihneadb@gmail.com>
Bug 904232 - Add inactivity timeout for marionette tests,r=jgriffin

diff --git a/testing/marionette/client/marionette/marionette.py b/testing/marionette/client/marionette/marionette.py
--- a/testing/marionette/client/marionette/marionette.py
+++ b/testing/marionette/client/marionette/marionette.py
@@ -699,16 +699,30 @@ class Marionette(object):
     @property
     def session_capabilities(self):
         '''
         A JSON dictionary representing the capabilities of the current session.
         '''
         response = self._send_message('getSessionCapabilities', 'value')
         return response
 
+    def set_script_inactivity_timeout(self, timeout):
+        '''
+        Sets the maximum number of ms that a script can be inactive.
+
+        If a script does not call any of the simpletest functions in the
+        specified amount of time, a ScriptTimeoutException is raised.
+
+        :param timeout: The maximum number of milliseconds a script is allowed
+         to run between calls to the simpletest functions without causing an
+         ScriptTimeoutException to be raised
+        '''
+        response = self._send_message('setScriptInactivityTimeout', 'ok', value=timeout)
+        return response
+
     def set_script_timeout(self, timeout):
         '''
         Sets the maximum number of ms that an asynchronous script is allowed to run.
 
         If a script does not return in the specified amount of time, a
         ScriptTimeoutException is raised.
 
         :param timeout: The maximum number of milliseconds an asynchronous
@@ -908,28 +922,32 @@ class Marionette(object):
                     unwrapped = HTMLElement(self, value[key])
                 else:
                     unwrapped[key] = self.unwrapValue(value[key])
         else:
             unwrapped = value
 
         return unwrapped
 
-    def execute_js_script(self, script, script_args=None, async=True, new_sandbox=True, special_powers=False, script_timeout=None, filename=None):
+    def execute_js_script(self, script, script_args=None, async=True,
+                          new_sandbox=True, special_powers=False,
+                          script_timeout=None, inactivity_timeout=None,
+                          filename=None):
         if script_args is None:
             script_args = []
         args = self.wrapArguments(script_args)
         response = self._send_message('executeJSScript',
                                       'value',
                                       value=script,
                                       args=args,
                                       async=async,
                                       newSandbox=new_sandbox,
                                       specialPowers=special_powers,
                                       scriptTimeout=script_timeout,
+                                      inactivity_timeout=inactivity_timeout,
                                       filename=filename,
                                       line=None)
         return self.unwrapValue(response)
 
     def execute_script(self, script, script_args=None, new_sandbox=True, special_powers=False, script_timeout=None):
         '''
         Executes a synchronous JavaScript script, and returns the result (or None if the script does return a value).
 
diff --git a/testing/marionette/client/marionette/marionette_test.py b/testing/marionette/client/marionette/marionette_test.py
--- a/testing/marionette/client/marionette/marionette_test.py
+++ b/testing/marionette/client/marionette/marionette_test.py
@@ -334,16 +334,17 @@ class MarionetteTestCase(CommonTestCase)
             time.sleep(0.5)
         else:
             raise TimeoutException("wait_for_condition timed out")
 
 class MarionetteJSTestCase(CommonTestCase):
 
     context_re = re.compile(r"MARIONETTE_CONTEXT(\s*)=(\s*)['|\"](.*?)['|\"];")
     timeout_re = re.compile(r"MARIONETTE_TIMEOUT(\s*)=(\s*)(\d+);")
+    inactivity_timeout_re = re.compile(r"MARIONETTE_INACTIVITY_TIMEOUT(\s*)=(\s*)(\d+);")
     match_re = re.compile(r"test_(.*)\.js$")
 
     def __init__(self, marionette_weakref, methodName='runTest', jsFile=None):
         assert(jsFile)
         self.jsFile = jsFile
         self._marionette_weakref = marionette_weakref
         self.marionette = None
         CommonTestCase.__init__(self, methodName)
@@ -383,20 +384,26 @@ class MarionetteJSTestCase(CommonTestCas
         if context != "chrome":
             self.marionette.navigate('data:text/html,<html>test page</html>')
 
         timeout = self.timeout_re.search(js)
         if timeout:
             timeout = timeout.group(3)
             self.marionette.set_script_timeout(timeout)
 
+        inactivity_timeout = self.inactivity_timeout_re.search(js)
+        if inactivity_timeout:
+            inactivity_timeout = inactivity_timeout.group(3)
+            self.marionette.set_script_inactivity_timeout(inactivity_timeout)
+
         try:
             results = self.marionette.execute_js_script(js,
                                                         args,
                                                         special_powers=True,
+                                                        inactivity_timeout=inactivity_timeout,
                                                         filename=os.path.basename(self.jsFile))
 
             self.assertTrue(not 'timeout' in self.jsFile,
                             'expected timeout not triggered')
 
             if 'fail' in self.jsFile:
                 self.assertTrue(results['failed'] > 0,
                                 "expected test failures didn't occur")
diff --git a/testing/marionette/marionette-listener.js b/testing/marionette/marionette-listener.js
--- a/testing/marionette/marionette-listener.js
+++ b/testing/marionette/marionette-listener.js
@@ -47,16 +47,20 @@ let sandbox;
 
 // the unload handler
 let onunload;
 
 // Flag to indicate whether an async script is currently running or not.
 let asyncTestRunning = false;
 let asyncTestCommandId;
 let asyncTestTimeoutId;
+
+let inactivityTimeoutId;
+let heartbeatCallback;
+
 let originalOnError;
 //timer for doc changes
 let checkTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
 // Send move events about this often
 let EVENT_INTERVAL = 30; // milliseconds
 // For assigning unique ids to all touches
 let nextTouchId = 1000;
 //Keep track of active Touches
@@ -328,18 +332,19 @@ function createExecuteContentSandbox(aWi
   sandbox.global = sandbox;
   sandbox.window = aWindow;
   sandbox.document = sandbox.window.document;
   sandbox.navigator = sandbox.window.navigator;
   sandbox.testUtils = utils;
   sandbox.asyncTestCommandId = asyncTestCommandId;
 
   let marionette = new Marionette(this, aWindow, "content",
-                                  marionetteLogObj,
-                                  timeout, marionetteTestName);
+                                  marionetteLogObj, timeout,
+                                  heartbeatCallback,
+                                  marionetteTestName);
   sandbox.marionette = marionette;
   marionette.exports.forEach(function(fn) {
     try {
       sandbox[fn] = marionette[fn].bind(marionette);
     }
     catch(e) {
       sandbox[fn] = marionette[fn];
     }
@@ -349,16 +354,20 @@ function createExecuteContentSandbox(aWi
     return new SpecialPowers(aWindow);
   });
 
   sandbox.asyncComplete = function sandbox_asyncComplete(value, status, stack, commandId) {
     if (commandId == asyncTestCommandId) {
       curFrame.removeEventListener("unload", onunload, false);
       curFrame.clearTimeout(asyncTestTimeoutId);
 
+      if (typeof inactivityTimeoutId != "undefined") {
+        curFrame.clearTimeout(inactivityTimeoutId);
+      }
+
       sendSyncMessage("Marionette:shareData",
                       {log: elementManager.wrapValue(marionetteLogObj.getLogs())});
       marionetteLogObj.clearLogs();
 
       if (status == 0){
         if (Object.keys(_emu_cbs).length) {
           _emu_cbs = {};
           sendError("Emulator callback still pending when finish() called",
@@ -371,16 +380,17 @@ function createExecuteContentSandbox(aWi
       }
       else {
         sendError(value, status, stack, commandId);
       }
 
       asyncTestRunning = false;
       asyncTestTimeoutId = undefined;
       asyncTestCommandId = undefined;
+      inactivityTimeoutId = undefined;
     }
   };
   sandbox.finish = function sandbox_finish() {
     if (asyncTestRunning) {
       sandbox.asyncComplete(marionette.generate_results(), 0, null, sandbox.asyncTestCommandId);
     } else {
       return marionette.generate_results();
     }
@@ -484,16 +494,31 @@ function setTestName(msg) {
 function executeAsyncScript(msg) {
   executeWithCallback(msg);
 }
 
 /**
  * Execute pure JS test. Handles both async and sync cases.
  */
 function executeJSScript(msg) {
+  if (msg.json.inactivityTimeout != null) {
+    inactivityTimeoutId = curFrame.setTimeout(function() {
+      sandbox.asyncComplete('timed out due to inactivity', 28, null, asyncTestCommandId);
+    }, msg.json.inactivityTimeout);
+
+    heartbeatCallback = function resetInactivityTimeout() {
+      curFrame.clearTimeout(inactivityTimeoutId);
+      inactivityTimeoutId = curFrame.setTimeout(function() {
+        sandbox.asyncComplete('timed out due to inactivity', 28, null, asyncTestCommandId);
+      }, msg.json.inactivityTimeout);
+    };
+  } else {
+    heartbeatCallback = function () {}
+  }
+
   if (msg.json.async) {
     executeWithCallback(msg, msg.json.async);
   }
   else {
     executeScript(msg, true);
   }
 }
 
@@ -511,17 +536,18 @@ function executeWithCallback(msg, useFin
 
   onunload = function() {
     sendError("unload was called", 17, null, asyncTestCommandId);
   };
   curFrame.addEventListener("unload", onunload, false);
 
   if (msg.json.newSandbox || !sandbox) {
     sandbox = createExecuteContentSandbox(curFrame,
-                                          msg.json.timeout);
+                                          msg.json.timeout,
+                                          heartbeatCallback);
     if (!sandbox) {
       sendError("Could not create sandbox!", 17, null, asyncTestCommandId);
       return;
     }
   }
   else {
     sandbox.asyncTestCommandId = asyncTestCommandId;
   }
diff --git a/testing/marionette/marionette-server.js b/testing/marionette/marionette-server.js
--- a/testing/marionette/marionette-server.js
+++ b/testing/marionette/marionette-server.js
@@ -123,16 +123,18 @@ function MarionetteServerConnection(aPre
   this.messageManager = this.globalMessageManager;
   this.browsers = {}; //holds list of BrowserObjs
   this.curBrowser = null; // points to current browser
   this.context = "content";
   this.scriptTimeout = null;
   this.searchTimeout = null;
   this.pageTimeout = null;
   this.timer = null;
+  this.inactivityTimer = null;
+  this.heartbeatCallback = function () {}; // we change it later if necessary
   this.marionetteLog = new MarionetteLogObj();
   this.command_id = null;
   this.mainFrame = null; //topmost chrome frame
   this.curFrame = null; // chrome iframe that currently has focus
   this.importedScripts = FileUtils.getFile('TmpD', ['marionettescriptchrome']);
   this.currentFrameElement = null;
   this.testName = null;
   this.mozBrowserClose = null;
@@ -705,17 +707,17 @@ MarionetteServerConnection.prototype = {
    *
    * @param object aRequest
    *        'value' member is the script to run
    *        'args' member holds the arguments to the script
    * @param boolean directInject
    *        if true, it will be run directly and not as a 
    *        function body
    */
-  execute: function MDA_execute(aRequest, directInject) {
+  execute: function MDA_execute(aRequest, directInject, inactivityTimeout) {
     let timeout = aRequest.scriptTimeout ? aRequest.scriptTimeout : this.scriptTimeout;
     let command_id = this.command_id = this.getCommandId();
     let script;
     this.logRequest("execute", aRequest);
     if (aRequest.newSandbox == undefined) {
       //if client does not send a value in newSandbox, 
       //then they expect the same behaviour as webdriver
       aRequest.newSandbox = true;
@@ -730,20 +732,45 @@ MarionetteServerConnection.prototype = {
                        specialPowers: aRequest.specialPowers,
                        filename: aRequest.filename,
                        line: aRequest.line
                      },
                      command_id);
       return;
     }
 
+    // handle the inactivity timeout
+    if (inactivityTimeout != null) {
+     this.inactivityTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+     if (this.inactivityTimer != null) {
+      this.inactivityTimer.initWithCallback(function() {
+       inactivityTimeoutHandler("timed out due to inactivity", 28);
+      }, inactivityTimeout, Ci.nsITimer.TYPE_ONESHOT);
+     }
+     let that = this;
+     this.heartbeatCallback = function resetInactivityTimer() {
+      that.inactivityTimer.cancel();
+      that.inactivityTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+      if (that.inactivityTimer != null) {
+       that.inactivityTimer.initWithCallback(function() {
+        inactivityTimeoutHandler("timed out due to inactivity", 28);
+       }, inactivityTimeout, Ci.nsITimer.TYPE_ONESHOT);
+      }
+     }
+    }
+    function inactivityTimeoutHandler(message, status) {
+     let error_msg = {message: value, status: status};
+     that.sendToClient({from: that.actorID, error: error_msg},
+                       marionette.command_id);
+    }
+
     let curWindow = this.getCurrentWindow();
     let marionette = new Marionette(this, curWindow, "chrome",
                                     this.marionetteLog,
-                                    timeout, this.testName);
+                                    timeout, this.heartbeatCallback, this.testName);
     let _chromeSandbox = this.createExecuteSandbox(curWindow,
                                                    marionette,
                                                    aRequest.args,
                                                    aRequest.specialPowers,
                                                    command_id);
     if (!_chromeSandbox)
       return;
 
@@ -788,48 +815,69 @@ MarionetteServerConnection.prototype = {
     }
     else {
       this.scriptTimeout = timeout;
       this.sendOk(this.command_id);
     }
   },
 
   /**
+   * Set the inactivity timeout for script execution
+   *
+   * @param object aRequest
+   *        'value' member is time in milliseconds to set timeout
+   */
+  setScriptInactivityTimeout: function MDA_setScriptInactivityTimeout(aRequest) {
+    this.command_id = this.getCommandId();
+    let timeout = parseInt(aRequest.value);
+    if(isNaN(timeout)){
+      this.sendError("Not a Number", 500, null, this.command_id);
+    }
+    else {
+      this.scriptInactivityTimeout = timeout;
+      this.sendOk(this.command_id);
+    }
+  },
+
+  /**
    * execute pure JS script. Used to execute 'mochitest'-style Marionette tests.
    *
    * @param object aRequest
    *        'value' member holds the script to execute
    *        'args' member holds the arguments to the script
    *        'timeout' member will be used as the script timeout if it is given
    */
   executeJSScript: function MDA_executeJSScript(aRequest) {
     let timeout = aRequest.scriptTimeout ? aRequest.scriptTimeout : this.scriptTimeout;
+    let inactivityTimeout = aRequest.inactivityTimeout ? aRequest.inactivityTimeout : this.scriptInactivityTimeout;
     let command_id = this.command_id = this.getCommandId();
+
     //all pure JS scripts will need to call Marionette.finish() to complete the test.
     if (aRequest.newSandbox == undefined) {
       //if client does not send a value in newSandbox, 
       //then they expect the same behaviour as webdriver
       aRequest.newSandbox = true;
     }
     if (this.context == "chrome") {
       if (aRequest.async) {
-        this.executeWithCallback(aRequest, aRequest.async);
+        this.executeWithCallback(aRequest, aRequest.async, inactivityTimeout);
       }
       else {
-        this.execute(aRequest, true);
+        this.execute(aRequest, true, inactivityTimeout);
       }
     }
     else {
       this.sendAsync("executeJSScript",
                      {
                        value: aRequest.value,
                        args: aRequest.args,
                        newSandbox: aRequest.newSandbox,
                        async: aRequest.async,
                        timeout: timeout,
+                       inactivityTimeout: inactivityTimeout,
                        specialPowers: aRequest.specialPowers,
                        filename: aRequest.filename,
                        line: aRequest.line,
                      },
                      command_id);
    }
   },
 
@@ -843,17 +891,17 @@ MarionetteServerConnection.prototype = {
    *
    * @param object aRequest
    *        'value' member holds the script to execute
    *        'args' member holds the arguments for the script
    * @param boolean directInject
    *        if true, it will be run directly and not as a 
    *        function body
    */
-  executeWithCallback: function MDA_executeWithCallback(aRequest, directInject) {
+  executeWithCallback: function MDA_executeWithCallback(aRequest, directInject, inactivityTimeout) {
     let timeout = aRequest.scriptTimeout ? aRequest.scriptTimeout : this.scriptTimeout;
     let command_id = this.command_id = this.getCommandId();
     let script;
     this.logRequest("executeWithCallback", aRequest);
     if (aRequest.newSandbox == undefined) {
       //if client does not send a value in newSandbox, 
       //then they expect the same behaviour as webdriver
       aRequest.newSandbox = true;
@@ -862,31 +910,52 @@ MarionetteServerConnection.prototype = {
     if (this.context == "content") {
       this.sendAsync("executeAsyncScript",
                      {
                        value: aRequest.value,
                        args: aRequest.args,
                        id: this.command_id,
                        newSandbox: aRequest.newSandbox,
                        timeout: timeout,
+                       inactivityTimeout: inactivityTimeout,
                        specialPowers: aRequest.specialPowers,
                        filename: aRequest.filename,
                        line: aRequest.line
                      },
                      command_id);
       return;
     }
 
+    // handle the inactivity timeout
+    if (inactivityTimeout != null) {
+     this.inactivityTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+     if (this.inactivityTimer != null) {
+      this.inactivityTimer.initWithCallback(function() {
+       chromeAsyncReturnFunc("timed out due to inactivity", 28);
+      }, inactivityTimeout, Ci.nsITimer.TYPE_ONESHOT);
+     }
+     let that = this;
+     this.heartbeatCallback = function resetInactivityTimer() {
+      that.inactivityTimer.cancel();
+      that.inactivityTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+      if (that.inactivityTimer != null) {
+       that.inactivityTimer.initWithCallback(function() {
+        chromeAsyncReturnFunc("timed out due to inactivity", 28);
+       }, inactivityTimeout, Ci.nsITimer.TYPE_ONESHOT);
+      }
+     }
+    }
+
     let curWindow = this.getCurrentWindow();
     let original_onerror = curWindow.onerror;
     let that = this;
     that.timeout = timeout;
     let marionette = new Marionette(this, curWindow, "chrome",
                                     this.marionetteLog,
-                                    timeout, this.testName);
+                                    timeout, this.heartbeatCallback, this.testName);
     marionette.command_id = this.command_id;
 
     function chromeAsyncReturnFunc(value, status, stacktrace) {
       if (that._emu_cbs && Object.keys(that._emu_cbs).length) {
         value = "Emulator callback still pending when finish() called";
         status = 500;
         that._emu_cbs = null;
       }
@@ -2159,16 +2228,17 @@ MarionetteServerConnection.prototype.req
   "newSession": MarionetteServerConnection.prototype.newSession,
   "getSessionCapabilities": MarionetteServerConnection.prototype.getSessionCapabilities,
   "getStatus": MarionetteServerConnection.prototype.getStatus,
   "log": MarionetteServerConnection.prototype.log,
   "getLogs": MarionetteServerConnection.prototype.getLogs,
   "setContext": MarionetteServerConnection.prototype.setContext,
   "executeScript": MarionetteServerConnection.prototype.execute,
   "setScriptTimeout": MarionetteServerConnection.prototype.setScriptTimeout,
+  "setScriptInactivityTimeout": MarionetteServerConnection.prototype.setScriptInactivityTimeout,
   "timeouts": MarionetteServerConnection.prototype.timeouts,
   "singleTap": MarionetteServerConnection.prototype.singleTap,
   "actionChain": MarionetteServerConnection.prototype.actionChain,
   "multiAction": MarionetteServerConnection.prototype.multiAction,
   "executeAsyncScript": MarionetteServerConnection.prototype.executeWithCallback,
   "executeJSScript": MarionetteServerConnection.prototype.executeJSScript,
   "setSearchTimeout": MarionetteServerConnection.prototype.setSearchTimeout,
   "findElement": MarionetteServerConnection.prototype.findElement,
diff --git a/testing/marionette/marionette-simpletest.js b/testing/marionette/marionette-simpletest.js
--- a/testing/marionette/marionette-simpletest.js
+++ b/testing/marionette/marionette-simpletest.js
@@ -1,72 +1,84 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 /*
  * The Marionette object, passed to the script context.
  */
 
-this.Marionette = function Marionette(scope, window, context, logObj, timeout, testName) {
+this.Marionette = function Marionette(scope, window, context, logObj, timeout,
+                                      heartbeatCallback, testName) {
   this.scope = scope;
   this.window = window;
   this.tests = [];
   this.logObj = logObj;
   this.context = context;
   this.timeout = timeout;
+  this.heartbeatCallback = heartbeatCallback;
   this.testName = testName;
   this.TEST_UNEXPECTED_FAIL = "TEST-UNEXPECTED-FAIL";
   this.TEST_PASS = "TEST-PASS";
   this.TEST_KNOWN_FAIL = "TEST-KNOWN-FAIL";
 }
 
 Marionette.prototype = {
   exports: ['ok', 'is', 'isnot', 'log', 'getLogs', 'generate_results', 'waitFor',
             'runEmulatorCmd', 'TEST_PASS', 'TEST_KNOWN_FAIL',
             'TEST_UNEXPECTED_FAIL'],
 
   ok: function Marionette__ok(condition, name, passString, failString, diag) {
+    this.heartbeatCallback();
     if (typeof(diag) == "undefined") {
       diag = this.repr(condition) + " was " + !!condition + ", expected true";
     }
     let test = {'result': !!condition, 'name': name, 'diag': diag};
     this.logResult(test,
                    typeof(passString) == "undefined" ? this.TEST_PASS : passString,
                    typeof(failString) == "undefined" ? this.TEST_UNEXPECTED_FAIL : failString);
     this.tests.push(test);
   },
 
   is: function Marionette__is(a, b, name, passString, failString) {
+    this.heartbeatCallback();
     let pass = (a == b);
     let diag = pass ? this.repr(a) + " should equal " + this.repr(b)
                     : "got " + this.repr(a) + ", expected " + this.repr(b);
     this.ok(pass, name, passString, failString, diag);
   },
 
   isnot: function Marionette__isnot (a, b, name, passString, failString) {
+    this.heartbeatCallback();
     let pass = (a != b);
     let diag = pass ? this.repr(a) + " should not equal " + this.repr(b)
                     : "didn't expect " + this.repr(a) + ", but got it";
     this.ok(pass, name, passString, failString, diag);
   },
 
   log: function Marionette__log(msg, level) {
+    if (typeof this.heartbeatCallback != "undefined") {
+      this.heartbeatCallback();
+    }
     dump("MARIONETTE LOG: " + (level ? level : "INFO") + ": " + msg + "\n");
     if (this.logObj != null) {
       this.logObj.log(msg, level);
     }
   },
 
   getLogs: function Marionette__getLogs() {
+    this.heartbeatCallback();
     if (this.logObj != null) {
       this.logObj.getLogs();
     }
   },
 
   generate_results: function Marionette__generate_results() {
+    if (typeof this.heartbeatCallback != "undefined") {
+      this.heartbeatCallback();
+    }
     let passed = 0;
     let failed = 0;
     let failures = [];
     for (let i in this.tests) {
       if(this.tests[i].result) {
         passed++;
       }
       else {
@@ -76,20 +88,22 @@ Marionette.prototype = {
       }
     }
     // Reset state in case this object is reused for more tests.
     this.tests = [];
     return {"passed": passed, "failed": failed, "failures": failures};
   },
 
   logToFile: function Marionette__logToFile(file) {
+    this.heartbeatCallback();
     //TODO
   },
 
   logResult: function Marionette__logResult(test, passString, failString) {
+    this.heartbeatCallback();
     //TODO: dump to file
     let resultString = test.result ? passString : failString;
     let diagnostic = test.name + (test.diag ? " - " + test.diag : "");
     let msg = resultString + " | " + this.testName + " | " + diagnostic;
     dump("MARIONETTE TEST RESULT:" + msg + "\n");
   },
 
   repr: function Marionette__repr(o) {
@@ -127,29 +141,31 @@ Marionette.prototype = {
           if (idx != -1) {
               o = o.substr(0, idx) + "{...}";
           }
       }
       return ostring;
   },
 
   waitFor: function test_waitFor(callback, test, timeout) {
+      this.heartbeatCallback();
       if (test()) {
           callback();
           return;
       }
       var now = Date.now();
       var deadline = now + (typeof(timeout) == "undefined" ? this.timeout : timeout);
       if (deadline <= now) {
         dump("waitFor timeout: " + test.toString() + "\n");
         // the script will timeout here, so no need to raise a separate
         // timeout exception
         return;
       }
       this.window.setTimeout(this.waitFor.bind(this), 100, callback, test, deadline - now);
   },
 
   runEmulatorCmd: function runEmulatorCmd(cmd, callback) {
+    this.heartbeatCallback();
     this.scope.runEmulatorCmd(cmd, callback);
   },
 
 };
 
