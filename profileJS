# HG changeset patch
# Parent e3785e299ab6ea4c4f6f318ff601d73c6be9198c
# User Mihnea Dobrescu-Balaur <mihneadb@gmail.com>
Bug 909577 - API for reading process info

diff --git a/toolkit/modules/ProcessInfo.jsm b/toolkit/modules/ProcessInfo.jsm
new file mode 100644
--- /dev/null
+++ b/toolkit/modules/ProcessInfo.jsm
@@ -0,0 +1,285 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+this.EXPORTED_SYMBOLS = [ "ProcessInfo" ];
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+const Cu = Components.utils;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/ctypes.jsm");
+
+let sysInfo = Cc["@mozilla.org/system-info;1"]
+                .getService(Ci.nsIPropertyBag2);
+let OS = {
+  name: sysInfo.getProperty("name"),
+  version: sysInfo.getProperty("version"),
+};
+
+
+function getFileFromPath(path) {
+  let file = Cc["@mozilla.org/file/local;1"]
+               .createInstance(Ci.nsILocalFile);
+  file.initWithPath(path);
+  return file;
+}
+
+function readFileAsLines(path) {
+  let file = getFileFromPath(path);
+  // open an input stream from file
+  let istream = Cc["@mozilla.org/network/file-input-stream;1"]
+                  .createInstance(Ci.nsIFileInputStream);
+  istream.init(file, 0x01, 0444, 0);
+  istream.QueryInterface(Ci.nsILineInputStream);
+
+  // read lines into array
+  let line = {}, lines = [], hasmore;
+  do {
+    hasmore = istream.readLine(line);
+    lines.push(line.value);
+  } while(hasmore);
+
+  istream.close();
+
+  return lines;
+}
+
+
+let Windows = {
+  getIOCounters: function () {
+    let IO_COUNTERS = new ctypes.StructType("IO_COUNTERS", [
+      {'readOps': ctypes.unsigned_long_long},
+      {'writeOps': ctypes.unsigned_long_long},
+      {'otherOps': ctypes.unsigned_long_long},
+      {'readBytes': ctypes.unsigned_long_long},
+      {'writeBytes': ctypes.unsigned_long_long},
+      {'otherBytes': ctypes.unsigned_long_long}
+    ]);
+    let kernel32 = ctypes.open('Kernel32.dll');
+
+    let GetProcessIoCounters = kernel32.declare('GetProcessIoCounters',
+                                                ctypes.winapi_abi,
+                                                ctypes.bool, // return type
+                                                ctypes.voidptr_t, // hProcess
+                                                IO_COUNTERS.ptr); // lpIoCounters
+
+    let GetCurrentProcess = kernel32.declare('GetCurrentProcess',
+                                             ctypes.winapi_abi,
+                                             ctypes.voidptr_t); // return type
+
+    let io = new IO_COUNTERS();
+    GetProcessIoCounters(GetCurrentProcess(), io.address());
+
+    let data = {
+      readBytes: parseInt(io.readBytes),
+      writeBytes: parseInt(io.writeBytes),
+      otherBytes: parseInt(io.otherBytes)
+    };
+    data.total = data.readBytes + data.writeBytes + data.otherBytes;
+    return data;
+  },
+
+  getCPUTimes: function () {
+    let FILETIME = new ctypes.StructType('_FILETIME', [
+      {'dwLowDateTime': ctypes.unsigned_long},
+      {'dwHighDateTime': ctypes.unsigned_long}
+    ]);
+    let SYSTEMTIME = new ctypes.StructType('_SYSTEMTIME', [
+      {'wYear': ctypes.unsigned_short},
+      {'wMonth': ctypes.unsigned_short},
+      {'wDayOfWeek': ctypes.unsigned_short},
+      {'wDay': ctypes.unsigned_short},
+      {'wHour': ctypes.unsigned_short},
+      {'wMinute': ctypes.unsigned_short},
+      {'wSecond': ctypes.unsigned_short},
+      {'wMilliseconds': ctypes.unsigned_short}
+    ]);
+    let kernel32 = ctypes.open('Kernel32.dll');
+
+    let GetCurrentProcess = kernel32.declare('GetCurrentProcess',
+                                             ctypes.winapi_abi,
+                                             ctypes.voidptr_t); // return type
+
+    let GetProcessTimes = kernel32.declare('GetProcessTimes',
+                                      ctypes.winapi_abi,
+                                      ctypes.bool, // return type
+                                      ctypes.voidptr_t, // hProcess
+                                      FILETIME.ptr, // lpCreationTime
+                                      FILETIME.ptr, // lpExitTime
+                                      FILETIME.ptr, // lpKernelTime
+                                      FILETIME.ptr); // lpUserTime
+
+    let FileTimeToSystemTime = kernel32.declare('FileTimeToSystemTime',
+                                          ctypes.winapi_abi,
+                                          ctypes.bool, // return type
+                                          FILETIME.ptr, // lpFileTime
+                                          SYSTEMTIME.ptr); // lpSystemTime
+
+    let creationTime = new FILETIME();
+    let exitTime = new FILETIME();
+    let kernelTime = new FILETIME();
+    let userTime = new FILETIME();
+
+    GetProcessTimes(GetCurrentProcess(),
+                  creationTime.address(),
+                  exitTime.address(),
+                  kernelTime.address(),
+                  userTime.address());
+
+    let processedKernelTime = new SYSTEMTIME();
+    let processedUserTime = new SYSTEMTIME();
+
+    FileTimeToSystemTime(kernelTime.address(), processedKernelTime.address());
+    FileTimeToSystemTime(userTime.address(), processedUserTime.address());
+
+    let data = {
+      user: parseInt(processedUserTime.wSecond) +
+            parseInt(processedUserTime.wMilliseconds) / 1000,
+      sys: parseInt(processedKernelTime.wSecond) +
+           parseInt(processedKernelTime.wMilliseconds) / 1000
+    };
+    data.total = data.user + data.sys;
+
+    return data;
+  },
+
+  getMemoryUsage: function () {
+    // TODO
+    return {total: 0};
+  },
+};
+
+
+let Linux = {
+  getIOCounters: function () {
+    let lines = readFileAsLines("/proc/self/io");
+    let total = 0;
+    let data = {};
+    lines.map(function(line) {
+      let [key, value] = line.split(":");
+      data[key] = value | 0;
+      total += data[key];
+    });
+    data.total = total;
+    return data;
+  },
+
+  getMemoryUsage: function () {
+    let lines = readFileAsLines("/proc/self/status");
+    let data = {};
+    let total = 0;
+    lines.map(function(line) {
+      let [key, value] = line.split(":");
+      if (key.startsWith("Vm")) {
+        data[key] = value.split(/\s+/)[1] | 0;
+        total += data[key];
+      }
+    });
+    data.total = total;
+    return data;
+  },
+
+  getCPUTimes: function () {
+    // using ctypes to get value of _SC_CLK_TCK
+    let libc = ctypes.open('libc.so');
+    let sysconf = libc.declare('sysconf',
+                               ctypes.default_abi,
+                               ctypes.long, // return type
+                               ctypes.int); // name
+    let _SC_CLK_TCK = sysconf(3); // #define _SC_CLK_TCK 3
+
+    let line = readFileAsLines("/proc/self/stat")[0];
+    let startPos = line.indexOf(")") + 2;
+    let values = line.substring(startPos).split(" ");
+    let data = {
+      user: (values[11] | 0) / _SC_CLK_TCK,
+      sys: (values[12] | 0) / _SC_CLK_TCK
+    };
+    data.total = data.user + data.sys;
+    return data;
+  },
+};
+
+
+let OSX = {
+  getIOCounters: function () {
+    // not available on OS X
+    return {total: 0};
+  },
+
+  getMemoryUsage: function () {
+    // data seems sketchy - peak is HUGE, rest are 0
+    usage = this.getrusage();
+    return {
+      peak: parseInt(usage.ru_maxrss),
+      shared: parseInt(usage.ru_ixrss),
+      unshared_data: parseInt(usage.ru_idrss),
+      unshared_stack: parseInt(usage.ru_isrss),
+      total: 0
+    };
+  },
+
+  getCPUTimes: function () {
+    usage = this.getrusage();
+    let data = {
+      user: parseInt(usage.ru_utime.tv_sec) +
+            parseInt(usage.ru_utime.tv_usec) / 1000000,
+      sys: parseInt(usage.ru_stime.tv_sec) +
+           parseInt(usage.ru_stime.tv_usec) / 1000000,
+    };
+    data.total = data.user + data.sys;
+    return data;
+  },
+
+  getrusage: function () {
+    let timeval = new ctypes.StructType("timeval", [
+      {'tv_sec': ctypes.long},
+      {'tv_usec': ctypes.long},
+    ]);
+    let rusage = new ctypes.StructType("rusage", [
+      {'ru_utime': timeval},             /* user CPU time used */
+      {'ru_stime': timeval},             /* system CPU time used */
+      {'ru_maxrss': ctypes.long},        /* maximum resident set size */
+      {'ru_ixrss': ctypes.long},         /* integral shared memory size */
+      {'ru_idrss': ctypes.long},         /* integral unshared data size */
+      {'ru_isrss': ctypes.long},         /* integral unshared stack size */
+      {'ru_minflt': ctypes.long},        /* page reclaims (soft page faults) */
+      {'ru_majflt': ctypes.long},        /* page faults (hard page faults) */
+      {'ru_nswap': ctypes.long},         /* swaps */
+      {'ru_inblock': ctypes.long},       /* block input operations */
+      {'ru_oublock': ctypes.long},       /* block output operations */
+      {'ru_msgsnd': ctypes.long},        /* IPC messages sent */
+      {'ru_msgrcv': ctypes.long},        /* IPC messages received */
+      {'ru_nsignals': ctypes.long},      /* signals received */
+      {'ru_nvcsw': ctypes.long},         /* voluntary context switches */
+      {'ru_nivcsw': ctypes.long},        /* involuntary context switches */
+    ]);
+    let sys = ctypes.open("libSystem.dylib");
+    let getrusage = sys.declare("getrusage",
+                                ctypes.default_abi,
+                                ctypes.int, // return type
+                                ctypes.int, // who
+                                rusage.ptr); // r_usage
+    let usage = new rusage();
+    usage.ru_utime = new timeval();
+    usage.ru_stime = new timeval();
+    let retVal = getrusage(0, usage.address());
+    return usage;
+  }
+};
+
+
+if (OS.name == 'Darwin') {
+  this.ProcessInfo = OSX;
+} else if (OS.name == 'Linux') {
+  this.ProcessInfo = Linux;
+} else if (OS.name == 'Windows_NT') {
+  this.ProcessInfo = Windows;
+} else {
+  this.ProcessInfo = null;
+}
+
diff --git a/toolkit/modules/moz.build b/toolkit/modules/moz.build
--- a/toolkit/modules/moz.build
+++ b/toolkit/modules/moz.build
@@ -14,16 +14,17 @@ EXTRA_JS_MODULES += [
     'Geometry.jsm',
     'Http.jsm',
     'InlineSpellChecker.jsm',
     'NewTabUtils.jsm',
     'PageMenu.jsm',
     'PopupNotifications.jsm',
     'Preferences.jsm',
     'PrivateBrowsingUtils.jsm',
+    'ProcessInfo.jsm',
     'Promise.jsm',
     'PropertyListUtils.jsm',
     'RemoteAddonsChild.jsm',
     'RemoteAddonsParent.jsm',
     'RemoteController.jsm',
     'RemoteSecurityUI.jsm',
     'RemoteWebNavigation.jsm',
     'RemoteWebProgress.jsm',
diff --git a/toolkit/modules/tests/xpcshell/test_ProcessInfo.js b/toolkit/modules/tests/xpcshell/test_ProcessInfo.js
new file mode 100644
--- /dev/null
+++ b/toolkit/modules/tests/xpcshell/test_ProcessInfo.js
@@ -0,0 +1,10 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+Components.utils.import("resource://gre/modules/ProcessInfo.jsm");
+
+function run_test() {
+  dump(JSON.stringify(ProcessInfo.getCPUTimes()) + "\n");
+  dump(JSON.stringify(ProcessInfo.getMemoryUsage()) + "\n");
+  dump(JSON.stringify(ProcessInfo.getIOCounters()) + "\n");
+}
diff --git a/toolkit/modules/tests/xpcshell/xpcshell.ini b/toolkit/modules/tests/xpcshell/xpcshell.ini
--- a/toolkit/modules/tests/xpcshell/xpcshell.ini
+++ b/toolkit/modules/tests/xpcshell/xpcshell.ini
@@ -9,8 +9,9 @@ tail =
 [test_Promise.js]
 [test_propertyListsUtils.js]
 [test_readCertPrefs.js]
 [test_Services.js]
 [test_sqlite.js]
 [test_task.js]
 [test_TelemetryTimestamps.js]
 [test_timer.js]
+[test_ProcessInfo.js]
