# HG changeset patch
# User Chris Manchester <cmanchester@mozilla.com>
# Date 1375810109 25200
#      Tue Aug 06 10:28:29 2013 -0700
# Node ID 50f40c51fb4529385bf7cd8251eba40b1ba59603
# Parent d1c07d6d65913e79fdd9ece667d62aaa16128f8f
Bug 887054 - Synchronize blocks of output when running xpcshell tests in parallel; f?mihneadb

diff --git a/testing/xpcshell/runxpcshelltests.py b/testing/xpcshell/runxpcshelltests.py
--- a/testing/xpcshell/runxpcshelltests.py
+++ b/testing/xpcshell/runxpcshelltests.py
@@ -9,30 +9,36 @@ import re, sys, os, os.path, logging, sh
 import xml.dom.minidom
 from collections import deque
 from distutils import dir_util
 from glob import glob
 from multiprocessing import cpu_count
 from optparse import OptionParser
 from subprocess import Popen, PIPE, STDOUT
 from tempfile import mkdtemp, gettempdir
-from threading import Timer, Thread, Semaphore
+from threading import Timer, Thread, Semaphore, RLock
 import random
 import socket
 import time
 
 try:
     import psutil
     HAVE_PSUTIL = True
 except ImportError:
     HAVE_PSUTIL = False
 
 from automation import Automation, getGlobalLog, resetGlobalLog
 from automationutils import *
 
+# Printing buffered output in case of a failure or verbose mode will result
+# in buffered output interleaved with other threads' output.
+# To prevent his, each call to the logger as well as any blocks of output that
+# are intended to be continuous are protected by the same lock.
+LOG_MUTEX = RLock()
+
 HARNESS_TIMEOUT = 5 * 60
 
 # benchmarking on tbpl revealed that this works best for now
 NUM_THREADS = int(cpu_count() * 4)
 
 # --------------------------------------------------------------
 # TODO: this is a hack for mozbase without virtualenv, remove with bug 849900
 #
@@ -351,20 +357,22 @@ class XPCShellTestThread(Thread):
             try:
                 self.removeDir(directory)
                 return True
             except Exception:
                 # we try this a few times - needed on Windows, at least
                 if try_count < TRY_LIMIT:
                     return self.cleanupDir(directory, name, stdout, xunit_result, try_count + 1)
 
+                LOG_MUTEX.acquire()
                 message = "TEST-UNEXPECTED-FAIL | %s | Failed to clean up directory: %s" % (name, sys.exc_info()[1])
                 self.log.error(message)
                 self.print_stdout(stdout)
                 self.print_stdout(traceback.format_exc())
+                LOG_MUTEX.release()
 
                 self.failCount += 1
                 xunit_result["passed"] = False
                 xunit_result["failure"] = {
                     "type": "TEST-UNEXPECTED-FAIL",
                     "message": message,
                     "text": "%s\n%s" % (stdout, traceback.format_exc())
                 }
@@ -470,36 +478,41 @@ class XPCShellTestThread(Thread):
                                                 re.MULTILINE)) or
                           # if e10s test started but never finished (child process crash)
                           (stdout and re.search("^child: CHILD-TEST-STARTED",
                                                 stdout, re.MULTILINE)
                                   and not re.search("^child: CHILD-TEST-COMPLETED",
                                                     stdout, re.MULTILINE)))
 
             if result != expected:
+                LOG_MUTEX.acquire()
                 failureType = "TEST-UNEXPECTED-%s" % ("FAIL" if expected else "PASS")
                 message = "%s | %s | test failed (with xpcshell return code: %d), see following log:" % (
                               failureType, name, self.getReturnCode(proc))
                 self.log.error(message)
                 self.print_stdout(stdout)
+                LOG_MUTEX.release()
+
                 self.failCount += 1
                 self.xunit_result["passed"] = False
 
                 self.xunit_result["failure"] = {
                   "type": failureType,
                   "message": message,
                   "text": stdout
                 }
             else:
                 now = time.time()
                 timeTaken = (now - startTime) * 1000
                 self.xunit_result["time"] = now - startTime
                 self.log.info("TEST-%s | %s | test passed (time: %.3fms)" % ("PASS" if expected else "KNOWN-FAIL", name, timeTaken))
                 if self.verbose:
+                    LOG_MUTEX.acquire()
                     self.print_stdout(stdout)
+                    LOG_MUTEX.release()
 
                 self.xunit_result["passed"] = True
 
                 if expected:
                     self.passCount = 1
                 else:
                     self.todoCount = 1
                     self.xunit_result["todo"] = True
@@ -516,19 +529,22 @@ class XPCShellTestThread(Thread):
 
             if self.logfiles and stdout:
                 self.createLogFile(name, stdout)
 
         finally:
             # We can sometimes get here before the process has terminated, which would
             # cause removeDir() to fail - so check for the process & kill it it needed.
             if proc and self.poll(proc) is None:
+                LOG_MUTEX.acquire()
                 message = "TEST-UNEXPECTED-FAIL | %s | Process still running after test!" % name
                 self.log.error(message)
                 self.print_stdout(stdout)
+                LOG_MUTEX.release()
+
                 self.failCount = 1
                 self.xunit_result["passed"] = False
                 self.xunit_result["failure"] = {
                   "type": "TEST-UNEXPECTED-FAIL",
                   "message": message,
                   "text": stdout
                 }
                 self.kill(proc)
@@ -566,16 +582,29 @@ class XPCShellTests(object):
 
     log = getGlobalLog()
     oldcwd = os.getcwd()
 
     def __init__(self, log=None):
         """ Init logging and node status """
         if log:
             resetGlobalLog(log)
+
+        # Each method of the underlying logger must acquire the log
+        # mutex before writing to stdout.
+        log_funs = ['debug', 'info', 'warning', 'error', 'critical']
+        for fun_name in log_funs:
+            if hasattr(self.log, fun_name):
+                unwrapped = getattr(self.log, fun_name)
+                def wrapped(*args, **kwargs):
+                    LOG_MUTEX.acquire()
+                    unwrapped(*args, **kwargs)
+                    LOG_MUTEX.release()
+                setattr(self.log, fun_name, wrapped)
+
         self.nodeProc = None
 
     def buildTestList(self):
         """
           read the xpcshell.ini manifest and set self.alltests to be
           an array of test objects.
 
           if we are chunking tests, it will be done here as well
