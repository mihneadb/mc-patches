# HG changeset patch
# Parent 0983f1a0961ceb4edf9012650393648d44773cd0
# User Mihnea Dobrescu-Balaur <mihneadb@gmail.com>
Bug 895572 - modules/libmar tests cannot be run concurrently, r=bbondy

diff --git a/modules/libmar/tests/unit/head_libmar.js.in b/modules/libmar/tests/unit/head_libmar.js.in
--- a/modules/libmar/tests/unit/head_libmar.js.in
+++ b/modules/libmar/tests/unit/head_libmar.js.in
@@ -6,16 +6,17 @@ const Cc = Components.classes;
 const Ci = Components.interfaces;
 
 #ifdef XP_WIN
   let refMARPrefix = "win_";
 #else
   let refMARPrefix = "";
 #endif
 
+let tempDir = do_get_tempdir();
 
 /**
  * Compares binary data of 2 arrays and throws if they aren't the same.
  * Throws on mismatch, does nothing on match.
  *
  * @param arr1 The first array to compare
  * @param arr2 The second array to compare
 */
diff --git a/modules/libmar/tests/unit/test_create.js b/modules/libmar/tests/unit/test_create.js
--- a/modules/libmar/tests/unit/test_create.js
+++ b/modules/libmar/tests/unit/test_create.js
@@ -11,17 +11,18 @@ function run_test() {
    * @param checkNoMAR     If true return an error if a file already exists
   */
   function run_one_test(refMARFileName, files, checkNoMAR) {
     if (checkNoMAR === undefined) {
       checkNoMAR = true;
     }
 
     // Ensure the MAR we will create doesn't already exist.
-    let outMAR = do_get_file("out.mar", true);
+    let outMAR = tempDir.clone();
+    outMAR.append("out.mar");
     if (checkNoMAR) {
       do_check_false(outMAR.exists());
     }
 
     // Create the actual MAR file.
     createMAR(outMAR, do_get_file("data"), files);
 
     // Get the reference MAR data.
@@ -52,24 +53,25 @@ function run_test() {
     test_multiple_file: function() {
       return run_one_test(refMARPrefix + "multiple_file_mar.mar", 
                           ["0_sized_file", "1_byte_file", "binary_data_file"]);
     },
     // Test creating a MAR file on top of a different one that already exists
     // at the location the new one will be created at.
     test_overwrite_already_exists: function() {
       let differentFile = do_get_file("data/1_byte_mar.mar");
-      let outMARDir = do_get_file(".");
+      let outMARDir = tempDir.clone();
       differentFile.copyTo(outMARDir, "out.mar");
       return run_one_test(refMARPrefix + "binary_data_mar.mar", 
                           ["binary_data_file"], false);
     },
     // Between each test make sure the out MAR does not exist.
     cleanup_per_test: function() {
-      let outMAR = do_get_file("out.mar", true);
+      let outMAR = tempDir.clone();
+      outMAR.append("out.mar");
       if (outMAR.exists()) {
         outMAR.remove(false);
       }
     }
   };
 
   // Run all the tests
   do_check_eq(run_tests(tests), Object.keys(tests).length - 1);
diff --git a/modules/libmar/tests/unit/test_extract.js b/modules/libmar/tests/unit/test_extract.js
--- a/modules/libmar/tests/unit/test_extract.js
+++ b/modules/libmar/tests/unit/test_extract.js
@@ -9,25 +9,27 @@ function run_test() {
    * @param marFileName The name of the MAR file to extract
    * @param files       The files that the extracted MAR should contain
   */
   function run_one_test(marFileName, files) { 
     // Get the MAR file that we will be extracting
     let mar = do_get_file("data/" + marFileName);
 
     // Get the path that we will extract to
-    let outDir = do_get_file("out", true);
+    let outDir = tempDir.clone();
+    outDir.append("out");
     do_check_false(outDir.exists());
     outDir.create(Ci.nsIFile.DIRECTORY_TYPE, 0777);
 
     // Get the ref files and the files that will be extracted.
     let outFiles = [];
     let refFiles = [];
     for (let i = 0; i < files.length; i++) {
-      let outFile = do_get_file("out/" + files[i], true);
+      let outFile = outDir.clone();
+      outFile.append(files[i]);
       do_check_false(outFile.exists());
 
       outFiles.push(outFile);
       refFiles.push(do_get_file("data/" + files[i]));
     }
 
     // Extract the MAR contents into the ./out dir.
     extractMAR(mar, outDir);
@@ -73,17 +75,18 @@ function run_test() {
     // Test extracting a MAR file with multiple files inside of it.
     test_multiple_file: function() {
       return run_one_test("multiple_file_mar.mar", 
                           ["0_sized_file", "1_byte_file", "binary_data_file"]);
     }, 
     // Between each test make sure the out directory and its subfiles do 
     // not exist.
     cleanup_per_test: function() {
-      let outDir = do_get_file("out", true);
+      let outDir = tempDir.clone();
+      outDir.append("out");
       if (outDir.exists()) {
         outDir.remove(true);
       }
     }
   };
 
   // Run all the tests
   do_check_eq(run_tests(tests), Object.keys(tests).length - 1);
diff --git a/modules/libmar/tests/unit/test_sign_verify.js b/modules/libmar/tests/unit/test_sign_verify.js
--- a/modules/libmar/tests/unit/test_sign_verify.js
+++ b/modules/libmar/tests/unit/test_sign_verify.js
@@ -222,57 +222,63 @@ function run_test() {
       do_check_eq(process.exitValue, 0);
     } else {
       do_check_neq(process.exitValue, 0);
     }
   }
 
 
   function cleanup() {
-    let outMAR = do_get_file("signed_out.mar", true);
+    let outMAR = tempDir.clone();
+    outMAR.append("signed_out.mar");
     if (outMAR.exists()) {
       outMAR.remove(false);
     }
-    outMAR = do_get_file("multiple_signed_out.mar", true);
+    outMAR = tempDir.clone();
+    outMAR.append("multiple_signed_out.mar");
     if (outMAR.exists()) {
       outMAR.remove(false);
     }
-    outMAR = do_get_file("out.mar", true);
+    outMAR = tempDir.clone();
+    outMAR.append("out.mar");
     if (outMAR.exists()) {
       outMAR.remove(false);
     }
 
-    let outDir = do_get_file("out", true);
+    let outDir = tempDir.clone();
+    outDir.append("out");
     if (outDir.exists()) {
       outDir.remove(true);
     }
   }
 
   const wantFailure = false;
   const wantSuccess = true;
   // Define the unit tests to run.
   let tests = {
     // Test signing a MAR file with a single signature
     test_sign_single: function() {
       let inMAR = do_get_file("data/" + refMARPrefix + "binary_data_mar.mar");
-      let outMAR = do_get_file("signed_out.mar", true);
+      let outMAR = tempDir.clone();
+      outMAR.append("signed_out.mar");
       if (outMAR.exists()) {
         outMAR.remove(false);
       }
       signMAR(inMAR, outMAR, ["mycert"], wantSuccess, true);
       do_check_true(outMAR.exists());
       let outMARData = getBinaryFileData(outMAR);
       let refMAR = do_get_file("data/" + refMARPrefix + "signed_pib_mar.mar");
       let refMARData = getBinaryFileData(refMAR);
       compareBinaryData(outMARData, refMARData);
     }, 
     // Test signing a MAR file with multiple signatures
     test_sign_multiple: function() {
       let inMAR = do_get_file("data/" + refMARPrefix + "binary_data_mar.mar");
-      let outMAR = do_get_file("multiple_signed_out.mar", true);
+      let outMAR = tempDir.clone();
+      outMAR.append("multiple_signed_out.mar");
       if (outMAR.exists()) {
         outMAR.remove(false);
       }
       do_check_false(outMAR.exists());
       signMAR(inMAR, outMAR, ["mycert", "mycert2", "mycert3"],
               wantSuccess, true);
       do_check_true(outMAR.exists());
       let outMARData = getBinaryFileData(outMAR);
@@ -353,32 +359,36 @@ function run_test() {
       do_check_false(noMAR.exists());
       verifyMAR(noMAR, wantFailure, ["mycert"], true);
     },
     // Test to make sure a stripped MAR is the same as the original MAR
     test_strip_signature: function() {
       let originalMAR = do_get_file("data/" + 
                                     refMARPrefix + 
                                     "binary_data_mar.mar");
-      let signedMAR = do_get_file("signed_out.mar");
-      let outMAR = do_get_file("out.mar", true);
+      let signedMAR = tempDir.clone();
+      signedMAR.append("signed_out.mar");
+      let outMAR = tempDir.clone();
+      outMAR.append("out.mar", true);
       stripMARSignature(signedMAR, outMAR, wantSuccess);
 
       // Verify that the stripped MAR matches the original data MAR exactly
       let outMARData = getBinaryFileData(outMAR);
       let originalMARData = getBinaryFileData(originalMAR);
       compareBinaryData(outMARData, originalMARData);
     },
     // Test to make sure a stripped multi-signature-MAR is the same as the original MAR
     test_strip_multiple_signatures: function() {
       let originalMAR = do_get_file("data/" +
                                     refMARPrefix +
                                     "binary_data_mar.mar");
-      let signedMAR = do_get_file("multiple_signed_out.mar");
-      let outMAR = do_get_file("out.mar", true);
+      let signedMAR = tempDir.clone();
+      signedMAR.append("multiple_signed_out.mar");
+      let outMAR = tempDir.clone();
+      outMAR.append("out.mar");
       stripMARSignature(signedMAR, outMAR, wantSuccess);
 
       // Verify that the stripped MAR matches the original data MAR exactly
       let outMARData = getBinaryFileData(outMAR);
       let originalMARData = getBinaryFileData(originalMAR);
       compareBinaryData(outMARData, originalMARData);
     },
     // Test extracting the first signature in a MAR that has only a single signature
@@ -419,17 +429,18 @@ function run_test() {
       }
       const outOfBoundsIndex = 5;
       extractMARSignature(inMAR, outOfBoundsIndex, extractedSig, wantFailure);
       do_check_false(extractedSig.exists());
     },
     // Test signing a file that doesn't exist fails
     test_bad_path_sign_fails: function() {
       let inMAR = do_get_file("data/does_not_exist_.mar", true);
-      let outMAR = do_get_file("signed_out.mar", true);
+      let outMAR = tempDir.clone();
+      outMAR.append("signed_out.mar");
       do_check_false(inMAR.exists());
       signMAR(inMAR, outMAR, ["mycert"], wantFailure, true);
       do_check_false(outMAR.exists());
     },
     // Test verifying only a subset of the signatures fails.
     // The input MAR has: mycert, mycert2, mycert3.
     // We're only verifying 2 of the 3 signatures and that should fail.
     test_verify_multiple_subset: function() {
@@ -443,17 +454,18 @@ function run_test() {
       let inMAR = do_get_file("data/signed_pib_mar.mar");
       verifyMAR(inMAR, wantSuccess, ["mycert"], false);
       verifyMAR(inMAR, wantFailure, ["mycert2"], false);
       verifyMAR(inMAR, wantFailure, ["mycert3"], false);
 
       // Get the signature file for this MAR signed with the key from mycert2
       let sigFile = do_get_file("data/signed_pib_mar.signature.mycert2");
       do_check_true(sigFile.exists());
-      let outMAR = do_get_file("data/sigchanged_signed_pib_mar.mar", true);
+      let outMAR = tempDir.clone();
+      outMAR.append("sigchanged_signed_pib_mar.mar");
       if (outMAR.exists()) {
         outMAR.remove(false);
       }
 
       //Run the import operation
       importMARSignature(inMAR, 0, sigFile, outMAR, wantSuccess);
 
       // Verify we have a new MAR file and that mycert no longer verifies
@@ -478,17 +490,18 @@ function run_test() {
       let inMAR = do_get_file("data/signed_pib_mar.mar");
       verifyMAR(inMAR, wantSuccess, ["mycert"], false);
       verifyMAR(inMAR, wantFailure, ["mycert2"], false);
       verifyMAR(inMAR, wantFailure, ["mycert3"], false);
 
       // Get the signature file for this MAR signed with the key from mycert2
       let sigFile = do_get_file("data/multiple_signed_pib_mar.sig.0");
       do_check_true(sigFile.exists());
-      let outMAR = do_get_file("data/sigchanged_signed_pib_mar.mar", true);
+      let outMAR = tempDir.clone();
+      outMAR.append("sigchanged_signed_pib_mar.mar");
       if (outMAR.exists()) {
         outMAR.remove(false);
       }
 
       //Run the import operation
       importMARSignature(inMAR, 0, sigFile, outMAR, wantSuccess);
 
       // Verify we have a new MAR file and that mycert no longer verifies
@@ -504,17 +517,18 @@ function run_test() {
       // Make sure the input MAR was signed with mycert only
       let inMAR = do_get_file("data/multiple_signed_pib_mar.mar");
       verifyMAR(inMAR, wantSuccess, ["mycert", "mycert2", "mycert3"], false);
       verifyMAR(inMAR, wantFailure, ["mycert", "mycert", "mycert3"], false);
 
       // Get the signature file for this MAR signed with the key from mycert
       let sigFile = do_get_file("data/multiple_signed_pib_mar.sig.0");
       do_check_true(sigFile.exists());
-      let outMAR = do_get_file("data/sigchanged_signed_pib_mar.mar", true);
+      let outMAR = tempDir.clone();
+      outMAR.append("sigchanged_signed_pib_mar.mar");
       if (outMAR.exists()) {
         outMAR.remove(false);
       }
 
       //Run the import operation
       const secondSigPos = 1;
       importMARSignature(inMAR, secondSigPos, sigFile, outMAR, wantSuccess);
 
@@ -531,17 +545,18 @@ function run_test() {
       let refMARData = getBinaryFileData(refMAR);
       let outMARData = getBinaryFileData(outMAR);
       compareBinaryData(outMARData, refMARData);
     },
     // Test stripping a MAR that doesn't exist fails 
     test_bad_path_strip_fails: function() {
       let noMAR = do_get_file("data/does_not_exist_mar", true);
       do_check_false(noMAR.exists());
-      let outMAR = do_get_file("out.mar", true);
+      let outMAR = tempDir.clone();
+      outMAR.append("out.mar");
       stripMARSignature(noMAR, outMAR, wantFailure);
     },
     // Test extracting from a bad path fails
     test_extract_bad_path: function() {
       let noMAR = do_get_file("data/does_not_exist.mar", true);
       let extractedSig = do_get_file("extracted_signature", true);
       do_check_false(noMAR.exists());
       if (extractedSig.exists()) {
